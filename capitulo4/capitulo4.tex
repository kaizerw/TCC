\chapter{Soluções: Resultados e Discussões}
\label{CapSolucoes}

\section{Introdução}

Neste capítulo são apresentados e discutidos os resultados obtidos por meio da execução de simulações utilizando as implementações realizadas. São apresentados os tempos de execução e os \textit{speedups} obtidos com a execução dos testes, bem como os resultados visuais para a dinâmica, por meio das saídas espaço-temporais geradas com auxílio do \textit{software} SIMULA e as curvas de quantidades, que expressam as quantidades de estado da população durante o tempo de simulação. São comparados empiricamente os resultados obtidos, tanto pela execução das simulações de forma sequencial e paralela, quanto pelas estratégias de implementação empregadas, como a convencional e a \textit{bitstring}. Por fim são apresentadas as conclusões obtidas a partir dos estudos realizados durante o desenvolvimento deste trabalho e sugestões para atividades ou trabalhos futuros.

\section{Discussões Qualitativas, Quantitativas, Eficiência e Acurácia}

Na Tabela \ref{tab:parametros} são apresentados os parâmetros utilizados na execução das simulações. À obtenção dos resultados foi empregada a metodologia de Monte Carlo \cite{MonteCarlo}, que consiste na execução de determinada quantidade de simulações, tomando-se ao final a média aritmética, que é utilizada para a análise dos resultados. A distribuição inicial das quantidades de indivíduos foi realizada de forma uniforme entre os lotes, ou seja, em cada lote são inseridos $16830 / 17 = 990$ indivíduos no estado suscetível e $170 / 17 = 10$ no estado infectado.

\newpage

\begin{table}[h!]
\centering
\begin{tabular}{c|c|c}
  Parâmetro	 			& Valor Mínimo	 	& Valor Máximo	\\ \hline
  Quantidade de Simulações		& $100$ 		& $100$ 	\\
  Quantidade de Ciclos			& $500$			& $500$ 	\\
  Quantidade de Suscetíveis		& $16830$ 		& $16830$ 	\\
  Quantidade de Expostos		& $0$			& $0$ 		\\
  Quantidade de Infectados		& $170$			& $170$ 	\\
  Quantidade de Recuperados		& $0$			& $0$ 		\\
  Taxa de Infecção $\beta$		& $0.90$ 		& $0.95$ 	\\
  Período de Exposição $\gamma$		& $15$			& $20$ 		\\
  Período de Infectância $\alpha$	& $30$ 			& $35$ 		\\
  Período de Recuperação $\delta$	& $40$			& $45$ 		\\
\end{tabular}
\caption{Parâmetros utilizados nas simulações executadas.}
\label{tab:parametros}
\end{table} 

A Tabela \ref{tab:dimensoes_matrizes} apresenta as dimensões das matrizes utilizadas no sistema de simulação para aproximar as geometrias dos lotes da quadra 445, ilustrada nas Figuras \ref{fig:q445-0} e \ref{fig:q445-1} da seção \ref{CapMetodologiasComputacionais}. A quadra 445 da cidade de Cascavel/PR foi utilizada como estudo de caso ao problema, servindo como base à definição do ambiente computacional para execução das simulações. As dimensões apresentadas foram obtidas com auxílio da ferramenta SIMULA, utilizando-se os processos já apresentados e discutidos na seção \ref{sec:SIMULA}.

\begin{table}[h!]
\centering
\begin{tabular}{c|c|c|c}
		& Lote	 	& Quantidade de Linhas	 	& Quantidade de Colunas		\\ \hline
  0		& 001		& $14$	 			& $9$			 	\\
  1		& 002-1		& $3$	 			& $13$			 	\\
  2		& 002-2		& $4$	 			& $5$			 	\\
  3		& 011		& $21$	 			& $17$			 	\\
  4		& 013		& $13$	 			& $9$			 	\\
  5		& 014		& $14$	 			& $9$			 	\\
  6		& 015		& $14$	 			& $9$			 	\\
  7		& 016		& $12$	 			& $10$			 	\\
  8		& 017		& $25$	 			& $13$			 	\\
  9		& 018		& $45$	 			& $13$			 	\\
  10		& 03B		& $19$	 			& $34$			 	\\
  11		& 03C		& $19$	 			& $34$			 	\\
  12		& 03E		& $10$	 			& $11$			 	\\
  13		& 03F		& $11$	 			& $11$			 	\\
  14		& 19A		& $45$	 			& $13$			 	\\
  15		& 19B-1		& $22$	 			& $5$			 	\\
  16		& 19B-2		& $9$	 			& $21$			 	\\
\end{tabular}
\caption{Dimensões das matrizes utilizadas para representação dos lotes.}
\label{tab:dimensoes_matrizes}
\end{table} 

Os tempos de execução e \textit{speedups} obtidos para as implementações convencionais e \textit{bitstring} são apresentados na Tabela \ref{tab:tempos}. O \textit{speedup}, no contexto deste trabalho, indica o aumento de desempenho entre a execução de simulações de forma sequencial, utilizando a CPU, e de forma paralela, utilizando a GPU. Especificamente, o \textit{speedup} indica o fator de redução no tempo de execução, quando a execução de uma simulação é realizada em GPU. 

\begin{table}[h!]
\centering
\begin{tabular}{c|c|c|c}
  Implementação 	& Tempo de Execução em CPU (s) 	& Tempo de Execução em GPU (s) 	& \textit{Speedup}	\\ \hline
  Convencional		& $14401$ 			& $1567$ 			& $9.19$ 		\\
  \textit{Bitstring}	& $15392$	 		& $1301$ 			& $11.83$ 		\\
\end{tabular}
\caption{Tempo de execução e \textit{speedups} obtidos para as diferentes implementações realizadas.}
\label{tab:tempos}
\end{table} 

Os resultados apresentados foram obtidos por meio da execução de simulações, utilizando a API CUDA à paralelização do sistema de simulação. Especificamente, para a execução de simulações na GPU utilizou-se uma placa gráfica Nvidia Tesla K20, que conta com 2496 \textit{cuda cores} com frequência de 706 MHz, 5 GB de memória e desempenho de $1.17$ Tflops e $3.52$ Tflops para ponto flutuante de precisão dupla e simples, respectivamente \cite{K20}. Para a execução de simulações em CPU, utilizou-se uma máquina com processador Intel Xeon E5-2620, que conta com 6 \textit{cores} e 12 \textit{threads} com frequência de 2 GHz, dispondo de 128 GB de memória. O computador em que as simulações foram executadas possui o sistema operacional Ubuntu 16.04. Utilizou-se \textit{scripts} escritos em \textit{shell script} \cite{ShellScript} para o controle da execução das simulações e obtenção dos tempos de execução. A máquina utilizada foi reiniciada antes do início da execução dos testes e somente os processos essenciais ao sistema operacional foram mantidos em execução.

Pode-se observar que, para a implementação convencional, o tempo de processamento foi reduzido em aproximadamente $9$ vezes. Já para a implementação em \textit{bitstring}, o tempo de processamento foi reduzido em aproximadamente $12$ vezes. É interessante notar que, os tempos de execução e \textit{speedups} têm valores aproximados entre as implementações convencionais e \textit{bitstring}. Portanto, pode-se concluir que, no caso da implementação realizada, não houve redução significativa no tempo de execução somente com a aplicação da técnica de \textit{bitstring}.

A Figura \ref{fig:quantidades} ilustra os resultados obtidos para a dinâmica epidemiológica utilizando os parâmetros apresentados na Tabela \ref{tab:parametros}. Estes gráficos foram obtidos por meio de pós-processamento, externo ao \textit{software} SIMULA, aplicado aos arquivos de saídas das simulações, utilizando um \textit{script} implementado na linguagem de programação Python \cite{Python}. Com estas saídas é possível observar o comportamento das populações de indivíduos suscetíveis, expostos, infectantes e recuperados durante o tempo de execução da simulação, representados pelas linhas nas cores verde, amarelo, vermelho e azul, respectivamente. Pode-se notar ainda que os resultados das diferentes implementações apresentadas nas figuras possuem dinâmicas assemelhadas entre si. Em geral, as implementações têm resultados qualitativamente assemelhados, apresentando algumas poucas diferenças quantitativas, discutidas em sequência. 

\begin{figure}[H]
  \centering
  \begin{minipage}{.5\textwidth}
    \centering
    \includegraphics[width=1.0\textwidth]{Figuras/Convencional_CPU.png}
    \captionsetup{labelformat=empty}
    \captionof{figure}{Implementação convencional em CPU}
  \end{minipage}%
  \begin{minipage}{.5\textwidth}
    \centering
    \includegraphics[width=1.0\textwidth]{Figuras/Convencional_GPU.png}
    \captionsetup{labelformat=empty}
    \captionof{figure}{Implementação convencional em GPU}
  \end{minipage}
  \centering
  \begin{minipage}{.5\textwidth}
    \centering
    \includegraphics[width=1.0\textwidth]{Figuras/Bitstring_CPU.png}
    \captionsetup{labelformat=empty}
    \captionof{figure}{Implementação \textit{bitstring} em CPU}
  \end{minipage}%
  \begin{minipage}{.5\textwidth}
    \centering
    \includegraphics[width=1.0\textwidth]{Figuras/Bitstring_GPU.png}
    \captionsetup{labelformat=empty}
    \captionof{figure}{Implementação \textit{bitstring} em GPU}
  \end{minipage}
  \caption{Gráficos das quantidades de indivíduos \textit{versus} tempo de simulação}
  \label{fig:quantidades}
\end{figure}

Inicialmente, as implementações CPU e GPU apresentavam resultados qualitativamente destoantes. Após a execução de testes verificou-se que esta diferença qualitativa estava relacionada aos mecanismos utilizados para a geração de números pseudo-aleatórios. Para as implementações em GPU, utiliza-se um gerador disponível na biblioteca \textit{Curand} \cite{Curand}, que gera números seguindo uma distribuição uniforme, enquanto que nas implementações em CPU eram utilizados geradores que não garantem tal comportamento, como a função \textit{rand} da biblioteca \textit{stdlib} \cite{Rand}. Para garantir a compatibilidade entre as duas implementações foram adotados nas implementações em CPU geradores de números pseudo-aleatórios que seguem uma distribuição uniforme, que estão disponíveis na biblioteca \textit{random} da linguagem C++ \cite{Random}. 

Após a compatibilização das distribuições utilizadas para a geração de números pseudo-aleatórios foram confeccionados gráficos para visualizar os erros relativos entre as implementações realizadas. Os erros relativos entre duas implementações foram calculados para cada população, ciclo a ciclo, utilizando-se as expressões \ref{eq:erro_relativo1} e \ref{eq:erro_relativo2}. Na expressão \ref{eq:erro_relativo1}, $CPU(i)$ e $GPU(i)$ designam as soluções em CPU e GPU, no ciclo $i$, respectivamente. Na expressão \ref{eq:erro_relativo2}, $C(i)$ e $B(i)$ designam as soluções convencionais e \textit{bitstring}, no ciclo $i$, respectivamente.

\begin{equation}
  E_R^{CPU, GPU} = \left|\frac{CPU(i) - GPU(i)}{CPU(i)}\right|
\label{eq:erro_relativo1}
\end{equation}

\begin{equation}
  E_R^{C, B} = \left|\frac{C(i) - B(i)}{C(i)}\right|
\label{eq:erro_relativo2}
\end{equation}

A Figura \ref{fig:acuracia_CPU_CPU} ilustra os erros relativos entre as implementações convencional e \textit{bitstring} em CPU, a Figura \ref{fig:acuracia_GPU_GPU} ilustra os erros relativos entre as implementações convencional e \textit{bitstring} em GPU, a Figura \ref{fig:acuracia_CPU_GPU_C} ilustra os erros relativos entre as implementações convencionais em CPU e GPU e a Figura \ref{fig:acuracia_GPU_GPU_B} ilustra os erros relativos entre as implementações \textit{bitstring} em CPU e GPU. As figuras que ilustram os erros relativos entre as implementações realizadas mostram que os resultados obtidos estão adequadamente próximos, independentemente da abordagem utilizada à representação dos indivíduos, convencional ou \textit{bitstring}, e da execução em CPU ou GPU, apresentando erros menores do que $0.588\%$.

Pode-se observar ainda que existem diversos picos para as populações de indivíduos em todos os resultados. Eles acontecem pois as quantidades de indivíduos são muito próximas de zero, o que acarreta em um aumento de sensibilidade no cálculo do erro relativo entre as quantidades. É possível observar, por meio da análise da Figura \ref{fig:quantidades} que, quando as quantidades de uma determinada população se aproximam de zero em um ciclo de tempo, os erros relativos entre suas implementações aumentam aproximadamente neste mesmo ciclo. 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.75\textwidth]{Figuras/Acuracia/1-erros_relativos_CPU_CPU.png}
  \caption{Gráficos dos erros relativos entre as implementações convencional e \textit{bitstring} em CPU.}
  \label{fig:acuracia_CPU_CPU}
\end{figure} 
  
\begin{figure}[H]
  \centering
  \includegraphics[width=0.75\textwidth]{Figuras/Acuracia/2-erros_relativos_GPU_GPU}
  \caption{Gráficos dos erros relativos entre as implementações convencional e \textit{bitstring} em GPU.}
  \label{fig:acuracia_GPU_GPU}
\end{figure} 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.75\textwidth]{Figuras/Acuracia/3-erros_relativos_CPU_GPU_C.png}
  \caption{Gráficos dos erros relativos entre as implementações convencionais em CPU e GPU.}
  \label{fig:acuracia_CPU_GPU_C}
\end{figure} 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.75\textwidth]{Figuras/Acuracia/4-erros_relativos_CPU_GPU_B.png}
  \caption{Gráficos dos erros relativos entre as implementações \textit{bitstring} em CPU e GPU.}
  \label{fig:acuracia_GPU_GPU_B}
\end{figure} 

\section{Dinâmicas Espaço-Temporais na Quadra 445.}

As Figuras \ref{fig:espacial_convencional} e \ref{fig:espacial_bitstring} mostram as saídas espaço-temporais obtidas por meio do \textit{software} SIMULA para a quadra 445. Pode-se observar que as duas implementações, convencional e \textit{bitstring} apresentam resultados assemelhados, não sendo idênticos devido a natureza estocástica dos processos de movimentação, contato e transição dos indivíduos. São apresentados, para cada implementação, o estado dos indivíduos na quadra, iniciando-se do ciclo 0, que corresponde à condição inicial, até o ciclo 100, em intervalos de 20 ciclos. Por meio das figuras é possível observar a evolução da dinâmica epidemiológica no domínio modelado.

\begin{figure}[H]
\centering
\begin{minipage}{.43\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Convencional/0.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 0.}
\end{minipage}
\begin{minipage}{.43\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Convencional/20.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 20.}
\end{minipage}
\begin{minipage}{.43\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Convencional/40.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 40.}
\end{minipage}
\begin{minipage}{.43\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Convencional/60.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 60.}
\end{minipage}
\begin{minipage}{.43\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Convencional/80.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 80.}
\end{minipage}
\begin{minipage}{.43\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Convencional/100.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 100.}
\end{minipage}
\caption{Dinâmica espaço-temporal para a implementação convencional.}
\label{fig:espacial_convencional}
\end{figure}

\begin{figure}[H]
\centering
\begin{minipage}{.43\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Bitstring/0.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 0.}
\end{minipage}
\begin{minipage}{.43\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Bitstring/20.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 20.}
\end{minipage}
\begin{minipage}{.43\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Bitstring/40.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 40.}
\end{minipage}
\begin{minipage}{.43\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Bitstring/60.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 60.}
\end{minipage}
\begin{minipage}{.43\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Bitstring/80.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 80.}
\end{minipage}
\begin{minipage}{.43\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Bitstring/100.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 100.}
\end{minipage}
\caption{Dinâmica espaço-temporal para a implementação \textit{bitstring}.}
\label{fig:espacial_bitstring}
\end{figure}

\newpage