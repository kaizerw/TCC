\chapter{Soluções: Resultados e Discussões}
\label{CapSolucoes}

\section{Introdução}

Neste capítulo são apresentados e discutidos os resultados obtidos por meio da execução de simulações utilizando as implementações realizadas. São apresentados os tempos de execução e os \textit{speedups} obtidos com a execução dos testes, bem como os resultados visuais para a dinâmica, por meio das saídas espaço-temporais geradas com auxílio do \textit{software} SIMULA e as curvas de quantidades, que expressam as quantidades de estado da população durante o tempo de simulação. São comparados empiricamente os resultados obtidos, tanto pela execução das simulações de forma sequencial e paralela, quanto pelas estratégias de implementação empregadas, como a convencional e a \textit{bitstring}. Por fim são apresentadas as conclusões obtidas a partir dos estudos realizados durante o desenvolvimento deste trabalho e sugestões para atividades ou trabalhos futuros.

\section{Discussões Qualitativas, Quantitativas, Eficiência e Acurácia}

Na Tabela \ref{tab:parametros} são apresentados os parâmetros utilizados na execução das simulações. À obtenção dos resultados foi empregada a metodologia de Monte Carlo \cite{MonteCarlo}, que consiste na execução de determinada quantidade de simulações, tomando-se ao final a média aritmética, que é utilizada para a análise dos resultados. A distribuição inicial das quantidades de indivíduos foi realizada de forma uniforme entre os lotes, ou seja, em cada lote são inseridos $16830 / 17 = 990$ indivíduos no estado suscetível e $170 / 17 = 10$ no estado infectado.

\newpage

\begin{table}[h!]
\centering
\begin{tabular}{c|c|c}
  Parâmetro	 			& Valor Mínimo	 	& Valor Máximo	\\ \hline
  Quantidade de Simulações		& $100$ 		& $100$ 	\\
  Quantidade de Ciclos			& $500$			& $500$ 	\\
  Quantidade de Suscetíveis		& $16830$ 		& $16830$ 	\\
  Quantidade de Expostos		& $0$			& $0$ 		\\
  Quantidade de Infectados		& $170$			& $170$ 	\\
  Quantidade de Recuperados		& $0$			& $0$ 		\\
  Taxa de Infecção $\beta$		& $0.90$ 		& $0.95$ 	\\
  Período de Exposição $\gamma$		& $15$			& $20$ 		\\
  Período de Infectância $\alpha$	& $30$ 			& $35$ 		\\
  Período de Recuperação $\delta$	& $40$			& $45$ 		\\
\end{tabular}
\caption{Parâmetros utilizados nas simulações executadas.}
\label{tab:parametros}
\end{table} 

A Tabela \ref{tab:dimensoes_matrizes} apresenta as dimensões das matrizes utilizadas no sistema de simulação para aproximar as geometrias dos lotes da quadra 445, ilustrada nas Figuras \ref{fig:q445-0} e \ref{fig:q445-1} da seção \ref{CapMetodologiasComputacionais}. As dimensões apresentadas foram obtidas com auxílio da ferramenta SIMULA, utilizando-se os processos já apresentados e discutidos na seção \ref{sec:SIMULA}.

\begin{table}[h!]
\centering
\begin{tabular}{c|c|c|c}
		& Lote	 	& Quantidade de Linhas	 	& Quantidade de Colunas		\\ \hline
  0		& 001		& $14$	 			& $9$			 	\\
  1		& 002-1		& $3$	 			& $13$			 	\\
  2		& 002-2		& $4$	 			& $5$			 	\\
  3		& 011		& $21$	 			& $17$			 	\\
  4		& 013		& $13$	 			& $9$			 	\\
  5		& 014		& $14$	 			& $9$			 	\\
  6		& 015		& $14$	 			& $9$			 	\\
  7		& 016		& $12$	 			& $10$			 	\\
  8		& 017		& $25$	 			& $13$			 	\\
  9		& 018		& $45$	 			& $13$			 	\\
  10		& 03B		& $19$	 			& $34$			 	\\
  11		& 03C		& $19$	 			& $34$			 	\\
  12		& 03E		& $10$	 			& $11$			 	\\
  13		& 03F		& $11$	 			& $11$			 	\\
  14		& 19A		& $45$	 			& $13$			 	\\
  15		& 19B-1		& $22$	 			& $5$			 	\\
  16		& 19B-2		& $9$	 			& $21$			 	\\
\end{tabular}
\caption{Dimensões das matrizes utilizadas para representação dos lotes.}
\label{tab:dimensoes_matrizes}
\end{table} 

Os tempos de execução e \textit{speedups} obtidos para as implementações convencionais e \textit{bitstring} são apresentados na Tabela \ref{tab:tempos}. O \textit{speedup}, no contexto deste trabalho, indica o aumento de desempenho entre a execução de simulações de forma sequencial, utilizando a CPU, e de forma paralela, utilizando a GPU. Especificamente, o \textit{speedup} indica então o fator de redução no tempo de execução, quando a execução de uma simulação é realizada em GPU. 

\begin{table}[h!]
\centering
\begin{tabular}{c|c|c|c}
  Implementação 	& Tempo de Execução em CPU (s) 	& Tempo de Execução em GPU (s) 	& \textit{Speedup}	\\ \hline
  Convencional		& $14401$ 			& $1567$ 			& $9.19$ 		\\
  \textit{Bitstring}	& $15392$	 		& $1301$ 			& $11.83$ 		\\
\end{tabular}
\caption{Tempo de execução e \textit{speedups} obtidos para as diferentes implementações realizadas.}
\label{tab:tempos}
\end{table} 

Os resultados apresentados foram obtidos por meio da execução de simulações, utilizando a API CUDA à paralelização do sistema de simulação. Especificamente, para a execução de simulações na GPU utilizou-se uma placa gráfica Nvidia Tesla K20, que conta com 2496 \textit{cuda cores} com frequência de 706 MHz, 5 GB de memória e desempenho de $1.17$ Tflops e $3.52$ Tflops para ponto flutuante de precisão dupla e simples, respectivamente \cite{K20}. Para a execução de simulações em CPU, utilizou-se uma máquina com processador Intel Xeon E5-2620, que conta com 6 \textit{cores} e 12 \textit{threads} com frequência de 2 GHz, dispondo de 128 GB de memória. O computador onde as simulações foram executadas possui o sistema operacional Ubuntu 16.04. Utilizou-se \textit{scripts} escritos em \textit{shell script} para o controle da execução das simulações e obtenção dos tempos de execução. A máquina utilizada foi reiniciada antes do início da execução dos testes e somente os processos essenciais ao sistema operacional foram mantidos em execução.

Pode-se observar que, para a implementação convencional, o tempo de processamento foi reduzido em aproximadamente $9$ vezes. Já para a implementação em \textit{bitstring}, o tempo de processamento foi reduzido em aproximadamente $12$ vezes. É interessante notar que, os tempos de execução e \textit{speedups} têm valores aproximados entre as implementações convencionais e \textit{bitstring}. Portanto, pode-se concluir que, no caso da implementação realizada, não houve redução significativa no tempo de execução somente com a aplicação da técnica de \textit{bitstring}.

As Figuras \ref{fig:convencional_cpu}, \ref{fig:convencional_gpu}, \ref{fig:bitstring_cpu} e \ref{fig:bitstring_gpu} ilustram os resultados obtidos para a dinâmica epidemiológica. Estes gráficos foram obtidos por meio de pós-processamento, externo ao \textit{software} SIMULA, aplicado aos arquivos de saídas das simulações, utilizando um \textit{script} implementado na linguagem de programação Python. Com estas saídas é possível observar o comportamento das populações de indivíduos suscetíveis, expostos, infectantes e recuperados durante o tempo de execução da simulação. Pode-se notar ainda que os resultados das diferentes implementações apresentadas nas figuras possuem dinâmicas assemelhadas entre si. Em geral, as implementações têm resultados qualitativamente assemelhados, apresentando algumas diferenças quantitativas. 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth]{Figuras/Convencional_CPU.png}
  \caption{Gráficos das quantidades de indivíduos \textit{versus} tempo de simulação para a implementação convencional em CPU.}
  \label{fig:convencional_cpu}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth]{Figuras/Convencional_GPU.png}
  \caption{Gráficos das quantidades de indivíduos \textit{versus} tempo de simulação para a implementação convencional em GPU.}
  \label{fig:convencional_gpu}
  \includegraphics[width=0.85\textwidth]{Figuras/Bitstring_CPU.png}
  \caption{Gráficos das quantidades de indivíduos \textit{versus} tempo de simulação para a implementação \textit{bitstring} em CPU.}
  \label{fig:bitstring_cpu}
\end{figure} 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth]{Figuras/Bitstring_GPU.png}
  \caption{Gráficos das quantidades de indivíduos \textit{versus} tempo de simulação para a implementação \textit{bitstring} em GPU.}
  \label{fig:bitstring_gpu}
\end{figure} 

Inicialmente, as implementações CPU e GPU apresentavam resultados qualitativamente destoantes. Após a execução de testes verificou-se que esta diferença qualitativa estava relacionada aos mecanismos utilizados para a geração de números pseudo-aleatórios. Para as implementações em GPU, utiliza-se um gerador disponível na biblioteca padrão CUDA, que gera números seguindo uma distribuição uniforme, enquanto que nas implementações em CPU eram utilizados geradores que não garantem tal comportamento, como a função \textit{rand} da biblioteca \textit{stdlib}. Para garantir a compatibilidade entre as duas implementações foram adotados nas implementações em CPU geradores de números pseudo-aleatórios que seguem uma distribuição uniforme, que estão disponíveis na biblioteca \textit{random} da linguagem C++. 

Após a compatibilização das distribuições utilizadas para a geração de números pseudo-aleatórios foram confeccionados gráficos para visualizar os erros relativos entre as implementações realizadas. Os erros relativos entre duas implementações foram calculados para cada população, ciclo a ciclo, utilizando-se a fórmula $ER_{a, b} = \frac{|a - b|}{a}$. A Figura \ref{fig:acuracia_CPU_CPU} ilustra os erros relativos entre as implementações convencional e \textit{bitstring} em CPU, a Figura \ref{fig:acuracia_GPU_GPU} ilustra os erros relativos entre as implementações convencional e \textit{bitstring} em GPU, a Figura \ref{fig:acuracia_CPU_GPU_C} ilustra os erros relativos entre as implementações convencionais em CPU e GPU e a Figura \ref{fig:acuracia_GPU_GPU_B} ilustra os erros relativos entre as implementações \textit{bitstring} em CPU e GPU. As figuras que ilustram os erros relativos entre as implementações realizadas mostram que os resultados obtidos estão adequadamente próximos, independentemente da abordagem utilizada à representação dos indivíduos, convencional ou \textit{bitstring}, e da execução em CPU ou GPU. 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.80\textwidth]{Figuras/Acuracia/1-erros_relativos_CPU_CPU.png}
  \caption{Gráficos dos erros relativos entre as implementações convencional e \textit{bitstring} em CPU.}
  \label{fig:acuracia_CPU_CPU}
\end{figure} 
  
\begin{figure}[H]
  \centering
  \includegraphics[width=0.80\textwidth]{Figuras/Acuracia/2-erros_relativos_GPU_GPU}
  \caption{Gráficos dos erros relativos entre as implementações convencional e \textit{bitstring} em GPU.}
  \label{fig:acuracia_GPU_GPU}
\end{figure} 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.80\textwidth]{Figuras/Acuracia/3-erros_relativos_CPU_GPU_C.png}
  \caption{Gráficos dos erros relativos entre as implementações convencionais em CPU e GPU.}
  \label{fig:acuracia_CPU_GPU_C}
  \includegraphics[width=0.80\textwidth]{Figuras/Acuracia/4-erros_relativos_CPU_GPU_B.png}
  \caption{Gráficos dos erros relativos entre as implementações \textit{bitstring} em CPU e GPU.}
  \label{fig:acuracia_GPU_GPU_B}
\end{figure} 

\section{Dinâmicas Espaço-Temporais na Quadra 445.}

As Figuras \ref{fig:espacial_convencional} e \ref{fig:espacial_bitstring} mostram as saídas espaço-temporais obtidas por meio do \textit{software} SIMULA para a quadra 445. Pode-se observar que as duas implementações, convencional e \textit{bitstring} apresentam resultados assemelhados, não sendo idênticos devido a natureza estocástica dos processos de movimentação, contato e transição dos indivíduos. São apresentados, para cada implementação, o estado dos indivíduos na quadra, iniciando-se do ciclo 0, que corresponde à condição inicial, até o ciclo 100, em intervalos de 20 ciclos. Por meio das figuras é possível observar a evolução da dinâmica epidemiológica no domínio modelado.

\begin{figure}[H]
\centering
\begin{minipage}{.33\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Convencional/0.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 0.}
\end{minipage}%
\begin{minipage}{.33\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Convencional/20.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 20.}
\end{minipage}
\begin{minipage}{.33\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Convencional/40.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 40.}
\end{minipage}
\begin{minipage}{.33\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Convencional/60.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 60.}
\end{minipage}%
\begin{minipage}{.33\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Convencional/80.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 80.}
\end{minipage}
\begin{minipage}{.33\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Convencional/100.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 100.}
\end{minipage}
\caption{Dinâmica espaço-temporal para a implementação convencional.}
\label{fig:espacial_convencional}
\end{figure}

\begin{figure}[H]
\centering
\begin{minipage}{.33\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Bitstring/0.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 0.}
\end{minipage}%
\begin{minipage}{.33\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Bitstring/20.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 20.}
\end{minipage}
\begin{minipage}{.33\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Bitstring/40.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 40.}
\end{minipage}
\begin{minipage}{.33\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Bitstring/60.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 60.}
\end{minipage}%
\begin{minipage}{.33\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Bitstring/80.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 80.}
\end{minipage}
\begin{minipage}{.33\textwidth}
  \centering
  \includegraphics[width=1\linewidth]{Figuras/Bitstring/100.png}
  \captionsetup{labelformat=empty}
  \caption*{t = 100.}
\end{minipage}
\caption{Dinâmica espaço-temporal para a implementação \textit{bitstring}.}
\label{fig:espacial_bitstring}
\end{figure}

\section{Conclusões}

Neste trabalho foi apresentado um modelo computacional multiagente para simular a propagação de hipotéticas doenças baseadas em modelagem compartimental tipo SEIRS. Utilizou-se uma ferramenta computacional especificamente desenvolvida para a geração de um mapeamento georreferenciado da quadra 445 da cidade de Cascavel/PR, que serviu como ambiente para a execução de simulações. Foi proposto um modelo em \textit{bitstring} para os agentes e operações relacionadas, facilitando o posterior emprego da biblioteca CUDA à paralelização do sistema de simulação. Por fim, apresentou-se os resultados obtidos com a execução de testes nas implementações realizadas, comparando-se os resultados obtidos entre as abordagens convencional e \textit{bitstring}, e as execuções sequenciais e paralelas. 

Conclui-se que o modelo multiagente implementado apresenta resultados interessantes, sobretudo sob o ponto de vista espaço-temporal, com dinâmica condizente com o esperado e mostrando a viabilidade da aplicação de modelos compartimentais à simulação de doenças hipotéticas sob áreas geográficas. O comportamento das populações de indivíduos suscetíveis, expostos, infectantes e recuperados, que podem ser observadas nos gráficos \ref{fig:convencional_cpu} a \ref{fig:bitstring_gpu}, também foi de acordo com o esperado, conforme observado em trabalhos correlatos disponíveis na literatura.

O emprego da ferramenta SIMULA à geração do ambiente utilizado na simulação foi importante ao desenvolvimento do trabalho, sobretudo nas etapas de pré e pós-processamento, como na geração de arquivos de entrada para a simulação e visualização dos resultados, especialmente em saídas georreferenciadas. Notou-se que há uma grande dificuldade no tratamento e disponibilização de dados georreferenciados, especialmente por exigirem na maioria das vezes, de algoritmos e tecnologias específicas no seu armazenamento e processamento.

A aplicação da técnica de \textit{bitstring} mostrou-se relevante, auxiliando na paralelização do sistema de simulação e diminuindo a quantidade de dados copiada entre CPU e GPU. Tal metodologia viabiliza ainda uma maneira concisa e uniforme de armazenamento e manipulação dos dados, sendo interessante sua aplicação no desenvolvimento de sistemas multiagente ou que modelem comportamentos individuais. 

Por fim, a aplicação da biblioteca CUDA para a paralelização das implementações realizadas mostrou-se interessante por reduzir expressivamente o tempo de execução das simulações, o que é desejável na execução de simulações com maior porte, com maior quantidade de indivíduos, em ambientes maiores e com modelagens mais complexas às dinâmicas epidemiológicas, que são situações mais próximas da realidade que deseja-se simular. Destaca-se ainda que a implementação de sistemas em GPU, embora facilitada por bibliotecas específicas como o CUDA, ainda apresenta diversas dificuldades e relativa complexidade, sobretudo quanto à adequação dos dados para viabilizar seu processamento em paralelo e transferência para a GPU, que pode demandar um longo período de planejamento e desenvolvimento. Especificamente neste trabalho foi necessária a vetorização de todas as estruturas de dados para viabilizar sua cópia para a GPU. Este processo pode não ser trivial, especialmente se a implementação que deseja-se paralelizar em GPU fizer uso de algoritmos complexos e estruturas de dados dinâmicas, como aquelas disponíveis em linguagens de programação de alto nível, como a biblioteca \textit{Standard Template Library}, STL, do C++. Adicionalmente foi necessária a adequação das rotinas paralelizadas, exigindo a eliminação de dependências que inviabilizam o processamento em paralelo, como as temporais, e organização da sequência de processamento dos dados de forma a viabilizar a computação por diferentes \textit{threads}, garantindo a consistência dos dados. 

Sugere-se como trabalhos futuros:

\begin{itemize}
 \item Desenvolvimento de modelos mais sofisticados para propagação de doenças, que incluam o agente vetor, viabilizando modelar comportamentos individuais como a movimentação na busca por acasalamento e alimento. Pode-se ainda modelar a aplicação de controles químicos, biológicos e mecânicos sobre a população de vetores.
 \item Aplicação da metodologia \textit{bitstring} sobre modelagens mais complexas, com agentes que apresentem mais atributos, que necessitem do uso de palavras computacionais com maior quantidade de \textit{bits}.
 \item Definição de um modelo \textit{bistring} \textit{in place}, que realize as operações de configuração de atributos utilizando uma quantidade mínima de variáveis auxiliares, reduzindo o consumo de memória do computador.
 \item Emprego e comparação de diferentes técnicas para paralelização do sistema de simulação, como por exemplo OpenMP, OpenMPI e outras APIs para programação em GPU.
 \item Estudo mais aprofundado sobre os parâmetros utilizados no modelo, sobretudo em suas influências sobre a dinâmica epidemiológica.
 \item Utilização de outros ambientes georreferenciados como base à simulação.
 \item Aprimoramento das estruturas de dados utilizadas, objetivando descartar a necessidade de vetorização. Pode-se estudar como realizar o uso ou mapeamento das estruturas de dados disponíveis na biblioteca STL do C++ com aquelas presentes na biblioteca \textit{Thrust} do CUDA.
\end{itemize}
