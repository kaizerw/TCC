\chapter{Metodologias e Modelagem Computacional}
\label{CapMetodologiasComputacionais}

\section{Introdução}
\label{sec:intro3}

Neste capítulo são apresentadas as metodologias computacionais utilizadas à realização deste trabalho. São discutidas as modelagens realizadas à representação do ambiente e dos indivíduos no sistema multiagente proposto, expondo-as em termos de operadores e ao uso da metodologia em \textit{bitstring}, as linguagens de programação e as motivações de seus usos, as estruturas de dados desenvolvidas à apropriada aplicação da modelagem \textit{bitstring} e paralelização em CUDA e estratégias de implementação do sistema multiagente. Em sequência é apresentado o \textit{software} especialmente desenvolvido à manipulação de informações georreferenciadas, que é utilizado como apoio às operações de configuração de parâmetros e do ambiente e à visualização de resultados das simulações que são executadas. Por fim são discutidas questões relativas à API para programação paralela CUDA, apresentando suas principais características e aplicações.

\section{Modelagem do Ambiente de Simulação}
\label{sec:modelagemAmbiente}

Para a modelagem do ambiente computacional, que servirá à execução de simulações da dinâmica epidemiológica, é utilizada como base uma região geográfica da cidade de Cascavel/PR, mais especificamente a quadra 445, que está localizada no centro da cidade de Cascavel/PR e é delimitada geograficamente pelas ruas Maranhão, Castro Alves, Curitiba e Visconde de Guarapuava. Esta quadra foi escolhida por ser um bom modelo geométrico, com relação às outras quadras da cidade, o que é interessante para desenvolver as estruturas de dados utilizadas na implementação do \textit{software}. As Figuras \ref{fig:q445-0} e \ref{fig:q445-1} ilustram a quadra em questão.

\begin{figure}[H]
\centering
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[width=0.95\linewidth]{Figuras/Q445-1.jpg}
  \captionof{figure}{Representação gráfica.}
  \label{fig:q445-0}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[width=0.95\linewidth]{Figuras/Q445-2.jpg}
  \captionof{figure}{Aproximação em matrizes.}
  \label{fig:q445-1}
\end{minipage}
\end{figure}

A quadra 445 contém 15 lotes, sendo necessário mapear cada um destes para uma estrutura matricial que viabilize sua representação e implementação no sistema de simulação. Para tanto, os lotes 0002 e 019B são divididos em outros dois lotes, pois apresentam geometria irregular de difícil aproximação em estruturas matriciais. Essa divisão é realizada de tal forma em que as matrizes resultantes representem, aproximadamente, a geometria original do lote dividido. Aos outros lotes da quadra 445 não foi aplicada nenhuma operação adicional, por apresentarem geometria regular, que pode ser facilmente aproximada por matrizes. Com as operações de divisão dos lotes irregulares, a quadra 445 que originalmente contém 15 lotes, é mapeada sobre um conjunto com 17 estruturas matriciais, que representam os lotes de forma apropriada à sua implementação computacional.

Como os lotes da quadra 445 são mapeados para estruturas matriciais que viabilizam sua implementação em linguagens de programação, à cada lote estará associada, no sistema de simulação, uma matriz de $n$ linhas e $m$ colunas, que representa sua região física. Essa especificação é importante pois à modelagem dos agentes é necessária a descrição do ambiente em que se movem e habitam. Cada agente terá uma determinada posição na quadra, que é completamente especificada pelas coordenadas $x$ e $y$ da matriz do lote e por um identificador do lote em que o agente se encontra. As coordenadas $x$ e $y$ representam, respectivamente, a linha e coluna da matriz do lote em que o agente está localizado. 

À modelagem das vizinhanças de uma determinada posição $(x, y)$ de um lote qualquer, é utilizada a vizinhança de Moore, que é amplamente aplicada na modelagem de autômatos celulares. A Figura \ref{fig:moore} ilustra graficamente os incrementos locais que são realizados às coordenadas de uma posição qualquer para a obtenção de sua vizinhança de Moore.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.25\textwidth]{Figuras/Vizinhanca_Moore.png}
  \caption{Representação indicial e local da vizinhança de Moore.}
  \label{fig:moore}
\end{figure} 

Assim sendo, do ponto de vista posicional, a vizinhança de Moore de uma posição $(x, y)$ qualquer consiste no conjunto das posições $(x, y + 1)$, $(x, y - 1)$, $(x + 1, y)$, $(x + 1, y + 1)$, $(x + 1, y - 1)$, $(x - 1, y)$, $(x - 1, y + 1)$ e $(x - 1, y - 1)$. A definição das vizinhanças de um determinada posição de um lote é relevante às operações de movimentação dos agentes da população, em que ocorre a simulação. 

\section{Modelagem em Operadores aos Agentes}
\label{sec:modelagemoperadores}

Os modelos apresentados na Seção \ref{sec:modeloscompartimentais} serviram à fundamentação do modelo baseado em agentes, que é desenvolvido e utilizado na implementação e execução de simulações computacionais. A modelagem empregada para simular o espalhamento de hipotética doença de transmissão direta em indivíduos considera agentes baseados em modelos, que são definidos espaço-temporalmente especificando-se como ocorre a transição do seu estado num intervalo de tempo e seu movimento no ambiente, de uma posição para outra no passo de tempo. Um passo de tempo é especificado como um ciclo de transição.

Um agente $\chi(t)$ é definido espaço-temporalmente especificando-se como ocorre a transição do seu estado num intervalo de tempo $t$ e seu movimento no espaço, que é o ambiente computacional em que o agente é especificado. O estado do agente é especificado por meio do conjunto de atributos, como apresentado em (\ref{especificacaoAgente}).
\begin{equation}
\label{especificacaoAgente}
 \chi(t) \equiv (L, X, Y, C, Q)
\end{equation}
cujos significados dos identificadores dos atributos do estado interno do agente $\chi(t)$ são como:

\begin{itemize}
 \item \textbf{Lote, $L$:} Identificador do lote que o agente $\chi(t)$ se encontra.
 \item \textbf{Posição em x, $X$:} Coordenada $x$ da posição do agente $\chi(t)$ no lote.
 \item \textbf{Posição em y, $Y$:} Coordenada $y$ da posição do agente $\chi(t)$ no lote.
 \item \textbf{Contador de controle, $C$:} Contador de ciclos que controla os períodos de transição entre os estados do agente.
 \item \textbf{Estado, $Q$:} Identificador do estado atual do agente $\chi(t)$.
\end{itemize}

A especificação formal de um agente é realizada por meio de um operador de evolução que define o estado atual do agente, quando interagindo com o ambiente. Esse operador decorre da composição entre os operadores de transição temporal, que realiza uma transição do estado interno do agente considerando-se sua interação com outros agentes e com o ambiente, e o operador de transição espacial, que movimenta o agente de sua posição para outra, considerando-se os atributos de conectividade e mobilidade. À dinâmica do agente são considerados três tipos de operações:

\begin{itemize}
 \item \textbf{Movimentação:} Nas operações de movimentação, os agentes são movimentados dentro de um ambiente virtual com topologia matricial por meio de suas vizinhanças de Moore às posições escolhidas aleatoriamente, respeitando-se os limites do ambiente.
 \item \textbf{Contato:} Nas operações de contato ocorre, probabilisticamente, a transmissão da doença por meio dos agentes infectados para os agentes suscetíveis que ocupam uma mesma posição no ambiente.
 \item \textbf{Transição de estados:} Nas transições de estados, ocorre a passagem de estados dos agentes de expostos para infectantes, de infectantes para recuperados e de recuperados para suscetíveis.
\end{itemize}

Tais operações são realizadas na sequência em que foram apresentadas e uma vez a cada ciclo, que consiste na aplicação dos operadores sobre a população de agentes e geração de arquivos de saída. Uma simulação é composta por uma determinada quantidade de ciclos.

Cada agente implementa uma operação de evolução $\lambda$ que atualiza o estado atual do agente quando interagindo com o ambiente, definido como $\lambda\big(\chi(t)\big)$, que decorre da composição entre os operadores $\mu$, $\rho$ e $\sigma$. O operador de transição espacial, $\mu$, movimenta o agente de sua posição considerando-se os atributos de conectividade e mobilidade; o operador $\rho$ realiza os contatos entre os agentes, que ocorrem com certa probabilidade; e o operador de transição temporal, $\sigma$, realiza a transição do estado interno do agente considerando sua interação com outros agentes e o ambiente. O operador de evolução $\lambda$ é definido como em (\ref{operador}).
\begin{equation}
  \label{operador}
  \lambda\big(\chi(t)^{(x, y)}\big) \equiv  \sigma\Big(\rho\big(\mu\big(\chi(t + 1)\big)\big)^{(\xi,\eta)}\Big)
\end{equation}
indicando que o agente $\chi$ realizou uma evolução da posição $(x,y)$ do ciclo $t$ à posição $(\xi,\eta)$ do ciclo posterior, $t+1$. Assim sendo, o operador espaço-temporal $\lambda(\chi)$ realiza as operações de movimentação, contato e de transição do agente $\chi$ movimentando-o da posição $(x,y)$ para uma posição $(\xi,\eta)$ do tempo atual, $t$, para tempo posterior, $t+1$.

\section{Modelagem em \textit{Bitstring} dos Agentes}
\label{sec:modelagembitstring}

A modelagem \textit{bitstring} realizada para a representação do agente é baseada na manipulação direta dos \textit{bits} em uma palavra computacional, que é capaz de caracterizar sem ambiguidade a especificação do agente $\chi(t)=\big(L, X, Y, C, Q\big)$, com identificador do lote, $L$, coordenada $x$ da posição, $X$, coordenada $y$ da posição, $Y$, contador de controle, $C$, e estado, $Q$.

Ao emprego de um modelo em \textit{bitstring} é necessário utilizar uma linguagem de programação que dê suporte apropriado às operações diretas com \textit{bits}. À implementação do sistema multiagente, visando alcançar os objetivos definidos neste trabalho, é proposta a utilização da linguagem de programação C, que provê suporte aos propósitos de modelagem e paralelização do sistema. O tipo de dado inteiro em C, \textit{int}, contém $32$ \textit{bits}, sendo suficiente à especificação da formulação para o agente $\chi(t)$ em termos de quantidade de \textit{bits}, como realizado a seguir.

À identificação do lote atual, $L$, do agente, considera-se que o identificador não ultrapasse $64$ valores, de modo que se supõe que uma quadra contenha no máximo $64$ lotes. À modelagem da posição $X, Y$ de um agente, considera-se que as quantidades de linhas, $\# L$, e de colunas, $\# C$, do ambiente, são limitadas por $max\big(\# L \times \# C\big)=\big(512 \times 512\big)$, em que $max$ indica o máximo possível de linhas e de colunas que podem ser alocadas à essa escolha, considerando-se que uma aproximação matricial de um lote de uma quadra resulta em uma matriz de no máximo $512 \times 512$ posições. À modelagem do contador de controle, $C$, de um agente, considera-se que a quantidade de ciclos em que um agente fica no estado exposto, infectado ou recuperado, não ultrapassem $64$ ciclos de simulação, pois supõe-se que a doença hipotética modelada não tem períodos de transição superior à esse valor. À modelagem do estado $Q$ de um agente, considerando a adoção do modelo compartimental tipo SEIRS, existem somente quatro distintos estados.

Assim sendo, observe que $512_{10} = 2^{9}$, $64_{10} = 2^{6}$ e $4_{10} = 2^{2}$, sendo suficiente uma palavra que comporte um quantidade de $32$ \textit{bits} para armazenar a especificação do agente $\chi(t)=\big(L, X, Y, C, Q\big)$ em \textit{bits}. A utilização de faixas maiores à representação dos atributos de um agente demandaria outros tipos de dados em C, com maior quantidade de \textit{bits}. A representação da palavra computacional proposta à modelagem dos agentes é como ilustrado na Figura \ref{fig:modelo_bitstring}, sendo que os elementos $l_i \in L$, $x_i \in X$, $y_i \in Y$, $c_i \in C$ e $q_i \in Q$ possuem o valor $0$ ou $1$ e seus índices subscritos indicam que cada \textit{bit} pode variar nos respectivos intervalos que estão especificados.
\begin{figure}[!htb]
  \centering
  \includegraphics[width=1.0\textwidth]{Figuras/Tira.jpg}
  \caption{Representação \textit{bitstring} do agente $\chi$.}
  \label{fig:modelo_bitstring}
\end{figure} 

Na Figura \ref{fig:modelo_bitstring}, os elementos do identificador do lote $L$ estão nas posições $31$ a $26$. Os elementos das coordenadas $X$ e $Y$ da posição do agente no lote estão nas posições $25$ a $17$ e $16$ a $8$, respectivamente. Os elementos do contador de controle, $C$, e do estado, $Q$, estão nas posições $7$ a $2$ e $1$ a $0$, respectivamente. Considerando as escolhas realizadas à sua modelagem, um agente qualquer do modelo pode ser representado em \textit{bits} como em (\ref{eq:bitstring}).
\begin{equation}
 \chi\big(L, X, Y, C, Q\big) \equiv \big(l_{31}, \dotsc, l_{26}; x_{25}, \dotsc, x_{17}; y_{16}, \dotsc, y_{8}; c_{7}, \dotsc, c_{2}; q_{1}, q_{0}\big)
 \label{eq:bitstring}
\end{equation}

Para identificar o lote e as coordenadas da posição do agente $\chi\big(L, X, Y, C, Q\big) = \chi(t)$ no ambiente, assim como seu estado interno e o registro de controle de ciclos às transições de estados, essas características são definidas como em (\ref{eq:bitstring_get}), para o ciclo $t$, em que $Pl$, $Px$, $Py$, $Pc$ e $Pq$ designam, respectivamente, as quantidades de \textit{bits} posteriores à cada campo.
\begin{equation}
  \begin{cases}
    L(t) = \chi\big(L, X, Y, C, Q\big) \ll_{arth}(Pl) \gg_{arth}(C\#l) \\
    X(t) = \chi\big(L, X, Y, C, Q\big) \ll_{arth}(Px) \gg_{arth}(C\#x) \\
    Y(t) = \chi\big(L, X, Y, C, Q\big) \ll_{arth}(Py) \gg_{arth}(C\#y) \\
    C(t) = \chi\big(L, X, Y, C, Q\big) \ll_{arth}(Pc) \gg_{arth}(C\#c) \\
    Q(t) = \chi\big(L, X, Y, C, Q\big) \ll_{arth}(Pq) \gg_{arth}(C\#q) \\
  \end{cases}
  \label{eq:bitstring_get}
\end{equation}

A quantidade de \textit{bits} posteriores à cada campo é a quantidade de \textit{bits} existentes que são mais significativos que aqueles do campo em questão. Os termos $C\#l$, $C\#x$, $C\#y$, $C\#c$ e $C\#q$ designam, respectivamente, as quantidades de \textit{bits} complementares a cada campo. A quantidade de \textit{bits} complementares a cada campo é a diferença entre a quantidade de \textit{bits} total da palavra e a quantidade de \textit{bits} do campo. As operações $\ll_{arth}$ e $\gg_{arth}$ designam, respectivamente, deslocamentos não circulares à esquerda e à direita na palavra, na quantidade de \textit{bits} indicado. As notações $\ll_{arth}$ e $\gg_{arth}$ advém daquelas nomenclaturas utilizadas na linguagem C para designar as operações de deslocamento ou \textit{shift} como deslocamentos aritméticos. 

Em deslocamentos aritméticos, como aqueles que são definidos na linguagem C, ocorre a preservação do \textit{bit} de sinal, quando da sua execução no sentido esquerda-direita. Deslocamentos que não preservam o \textit{bit} de sinal são chamados deslocamentos lógicos, que não são definidos na linguagem C. O uso do tipo de dado \textit{unsigned int} descarta a preservação de sinal na realização de \textit{shifts} ou deslocamentos, evitando a introdução de erro na manipulação dos \textit{bits} mais significativos em operações de captura e configuração de atributos de um agente, viabilizando o uso de deslocamentos aritméticos com o mesmo resultado prático obtido por deslocamentos lógicos, sendo o uso do tipo \textit{unsigned int} em C justificado por este motivo.

Na modelagem realizada, as especificações às quantidades são $Pl = 0$, $Px = 6$, $Py = 15$, $Pc = 24$, $Pq = 30$, $C\#l = 26$, $C\#x = 23$, $C\#y = 23$, $C\#c = 26$ e $C\#q = 30$, de modo que (\ref{eq:bitstring_get}) é então reescrita concretamente para a modelagem (\ref{eq:bitstring}) como em (\ref{eq:bitstring_get_2}).
\begin{equation}
  \begin{cases}
    L(t) = \chi\big(L, X, Y, C, Q\big) \ll_{arth}(0) \gg_{arth}(26) \\
    X(t) = \chi\big(L, X, Y, C, Q\big) \ll_{arth}(6) \gg_{arth}(23) \\
    Y(t) = \chi\big(L, X, Y, C, Q\big) \ll_{arth}(15) \gg_{arth}(23) \\
    C(t) = \chi\big(L, X, Y, C, Q\big) \ll_{arth}(24) \gg_{arth}(26) \\
    Q(t) = \chi\big(L, X, Y, C, Q\big) \ll_{arth}(30) \gg_{arth}(30) \\
  \end{cases}
  \label{eq:bitstring_get_2}
\end{equation}

As operações definidas em (\ref{eq:bitstring_get_2}) capturam informações armazenadas nos agentes, como especificado em (\ref{especificacaoAgente}).

Assim sendo, para o modelo \textit{bitstring} especificado neste trabalho, considera-se um agente $\chi(t)$ especificado como em (\ref{eq:ex_get_agente}), em que o símbolo $|$ designa o separador dos campos do agente.

\begin{equation}
  \chi(t) = 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \\
  \label{eq:ex_get_agente}
\end{equation}

A aplicação do operador de captura do campo de identificador do lote em que o agente $\chi(t)$ se encontra, como definido em (\ref{eq:bitstring_get_2}), é exemplificada como ilustrado em (\ref{eq:ex_get_l}).

\begin{equation}
  \begin{split}
  L(t) = & \chi(t) \ll_{arth}(0) \gg_{arth}(26) \\
       = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0  \ll_{arth}(0) \gg_{arth}(26) \\
       = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \gg_{arth}(26) \\
       = & 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 1 1 0 1 | 0 0 \\
       = & 1 1 0 1 0 0
  \label{eq:ex_get_l}
  \end{split}
\end{equation}

A aplicação do operador de captura do campo da coordenada $x$ do lote em que o agente $\chi(t)$ se encontra, como definido em (\ref{eq:bitstring_get_2}), é exemplificada como ilustrado em (\ref{eq:ex_get_x}).

\begin{equation}
  \begin{split}
  X(t) = & \chi(t) \ll_{arth}(6) \gg_{arth}(23) \\
       = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0  \ll_{arth}(6) \gg_{arth}(23) \\
       = & 0 0 1 0 1 0 | 1 0 0 0 1 1 0 0 1 | 0 1 1 0 0 1 1 1 0 | 1 0 0 0 0 0 | 0 0 \gg_{arth}(23) \\
       = & 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 1 0 1 0 1 | 0 0 \\
       = & 0 0 1 0 1 0 1 0 0
  \label{eq:ex_get_x}
  \end{split}
\end{equation}

A aplicação do operador de captura do campo da coordenada $y$ do lote em que o agente $\chi(t)$ se encontra, como definido em (\ref{eq:bitstring_get_2}), é exemplificada como ilustrado em (\ref{eq:ex_get_y}).

\begin{equation}
  \begin{split}
  Y(t) = & \chi(t) \ll_{arth}(15) \gg_{arth}(23) \\
       = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0  \ll_{arth}(15) \gg_{arth}(23) \\
       = & 0 1 1 0 0 1 | 0 1 1 0 0 1 1 1 0 | 1 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 | 0 0 \gg_{arth}(23) \\
       = & 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 1 1 0 0 1 0 | 1 1 \\
       = & 0 1 1 0 0 1 0 1 1
  \label{eq:ex_get_y}
  \end{split}
\end{equation}

A aplicação do operador de captura do campo do contador de transição de estados do agente $\chi(t)$, como definido em (\ref{eq:bitstring_get_2}), é exemplificada como ilustrado em (\ref{eq:ex_get_c}).

\begin{equation}
  \begin{split}
  C(t) = & \chi(t) \ll_{arth}(24) \gg_{arth}(26) \\
       = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0  \ll_{arth}(24) \gg_{arth}(26) \\
       = & 0 0 1 1 1 0 | 1 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 | 0 0 \gg_{arth}(26) \\
       = & 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 0 0 1 1 | 1 0 \\
       = & 0 0 1 1 1 0
  \label{eq:ex_get_c}
  \end{split}
\end{equation}

A aplicação do operador de captura do campo do estado do agente $\chi(t)$, como definido em (\ref{eq:bitstring_get_2}), é exemplificada como ilustrado em (\ref{eq:ex_get_e}).

\begin{equation}
  \begin{split}
  Q(t) = & \chi(t) \ll_{arth}(30) \gg_{arth}(30) \\
       = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0  \ll_{arth}(30) \gg_{arth}(30) \\
       = & 1 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 | 0 0 \gg_{arth}(30) \\
       = & 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 | 1 0 \\
       =  & 1 0
  \label{eq:ex_get_e}
  \end{split}
\end{equation}

Também são necessárias outras operações para manipular os atributos dos agentes, além daquelas definidas em (\ref{eq:bitstring_get_2}), como, por exemplo, operadores de deslocamentos circulares. Como a linguagem de programação C não conta com operador próprio que viabilize a execução de operações de deslocamentos circulares, faz-se necessário a sua definição com base nos operadores existentes na linguagem, como os deslocamentos aritméticos e operações lógicas. Em (\ref{eq:bitstring_circ}) $\ll_{circ}$ e $\gg_{circ}$ designam, respectivamente, deslocamentos circulares à esquerda e à direita na palavra, na quantidade de \textit{bits} indicado, definidos como uma composição dos operadores de deslocamento aritmético e a operação lógica ou.
\begin{equation}
  \begin{cases}
    \ll_{circ} = \big(M \ll_{arth}(shift)\big) \, \vee \, \big(M \gg_{arth}(N\_BITS - shift)\big) \\
    \gg_{circ} = \big(M \gg_{arth}(shift)\big) \, \vee \, \big(M \ll_{arth}(N\_BITS - shift)\big) \\
  \end{cases}
  \label{eq:bitstring_circ}
\end{equation}

Em (\ref{eq:bitstring_circ}), $M$ denota a palavra computacional em que está sendo aplicada a operação de deslocamento circular, $N\_BITS$ denota a quantidade de bits totais, \textit{shift} denota o fator de deslocamento e $\vee$ denota a operação lógica OR, "ou inclusivo", que é realizada \textit{bit} a \textit{bit} à palavra. Assim, a especificação às quantidades adotadas na modelagem, (\ref{eq:bitstring_circ}) é reescrita como em (\ref{eq:bitstring_circ_2}).
\begin{equation}
  \begin{cases}
    \ll_{circ} = \big(M \ll_{arth}(shift)\big) \, \vee \, \big(M \gg_{arth}(32 - shift)\big) \\
    \gg_{circ} = \big(M \gg_{arth}(shift)\big) \, \vee \, \big(M \ll_{arth}(32 - shift)\big) \\
  \end{cases}
  \label{eq:bitstring_circ_2}
\end{equation}

Em (\ref{eq:ex_circ_left}) é ilustrado um exemplo da aplicação do operador $\ll_{circ}$ definido em (\ref{eq:bitstring_circ_2}) em uma palavra computacional $M = 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 $ de 32 \textit{bits}, com $shift = 8$.

\begin{equation}
  \begin{split}
  \ll_{circ} = & \big(M \ll_{arth}(shift)\big) \, \vee \, \big(M \gg_{arth}(32 - shift)\big) \\
	     = & 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 \ll_{arth}(8) \, \vee \, \\
	     & 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 \gg_{arth}(32 - 8) \\
	     = & 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 \ll_{arth}(8) \, \vee \, \\
	     & 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 \gg_{arth}(24) \\
	     = & 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 | 0 0 0 0 0 0 0 0 \, \vee \, \\
	     & 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 1 1 0 1 0 0 0 0 \\
	     = & 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 | 1 1 0 1 0 0 0 0 \\
  \label{eq:ex_circ_left}
  \end{split}
\end{equation}

Em (\ref{eq:ex_circ_right}) é ilustrado um exemplo da aplicação do operador $\gg_{circ}$ definido em (\ref{eq:bitstring_circ_2}) em uma palavra computacional $M = 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 $ de 32 \textit{bits}, com $shift = 8$.

\begin{equation}
  \begin{split}
  \gg_{circ} = & \big(M \gg_{arth}(shift)\big) \, \vee \, \big(M \ll_{arth}(32 - shift)\big) \\
	     = & 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 \gg_{arth}(8) \, \vee \, \\
	     & 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 \ll_{arth}(32 - 8) \\
	     = & 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 \gg_{arth}(8) \, \vee \, \\
	     & 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 \ll_{arth}(24) \\  
	     = & 0 0 0 0 0 0 0 0 | 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 \, \vee \, \\
	     & 0 0 1 1 1 0 1 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0\\
	     = & 0 0 1 1 1 0 1 0 | 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 \\
  \label{eq:ex_circ_right}
  \end{split}
\end{equation}

Subsequentemente são utilizadas as operações definidas em (\ref{eq:bitstring_circ_2}), para implementar o operador espaço-temporal $\lambda\big(\chi(t)\big)$ que movimenta o agente da posição $(x, y)$ para uma posição $\big(\xi, \eta\big)$ no ciclo de tempo atual $t$, para o ciclo de tempo $t+1$. As operações definidas em (\ref{eq:bitstring_set}) resultam na atualização dos atributos de identificação do lote, das coordenadas $x$ e $y$ da posição, do controle e do estado do agente.
\begin{equation}
  \begin{cases}
    \chi\big(L(t + 1), X(t), Y(t), C(t), Q(t)\big) = & \chi\big(L(t), X(t), Y(t), C(t), Q(t)\big) \\
    & \gg_{circ}(Al) \gg_{arth}(\#l) \ll_{arth} (\#l) \\
    & \, \vee \, L(t + 1) \ll_{circ}(Al) \\
    \chi\big(L(t), X(t + 1), Y(t), C(t), Q(t)\big) = & \chi\big(L(t), X(t), Y(t), C(t), Q(t)\big) \\
    & \gg_{circ}(Ax) \gg_{arth}(\#x) \ll_{arth} (\#x) \\
    & \, \vee \, X(t + 1) \ll_{circ}(Ax) \\
    \chi\big(L(t), X(t), Y(t + 1), C(t), Q(t)\big) = & \chi\big(L(t), X(t), Y(t), C(t), Q(t)\big) \\
    & \gg_{circ}(Ay) \gg_{arth}(\#y) \ll_{arth} (\#y) \\
    & \, \vee \, Y(t + 1) \ll_{circ}(Ay) \\
    \chi\big(L(t), X(t), Y(t), C(t + 1), Q(t)\big) = & \chi\big(L(t), X(t), Y(t), C(t), Q(t)\big) \\
    & \gg_{circ}(Ac) \gg_{arth}(\#c) \ll_{arth} (\#c) \\
    & \, \vee \, C(t + 1) \ll_{circ}(Ac) \\
    \chi\big(L(t), X(t), Y(t), C(t), Q(t + 1)\big) = & \chi\big(L(t), X(t), Y(t), C(t), Q(t)\big) \\
    & \gg_{circ}(Aq) \gg_{arth}(\#q) \ll_{arth} (\#q) \\
    & \, \vee \, Q(t + 1) \ll_{circ}(Aq) \\
  \end{cases}
  \label{eq:bitstring_set}
\end{equation}

Em (\ref{eq:bitstring_set}), $Al$, $Ax$, $Ay$, $Ac$ e $Aq$ designam, respectivamente, as quantidades de \textit{bits} anteriores a cada campo. A quantidade de \textit{bits} anteriores a cada campo é a quantidade de \textit{bits} existentes que são menos significativos que aqueles do campo em questão. Os termos $\#l$, $\#x$, $\#y$, $\#c$ e $\#q$ designam, respectivamente, as quantidades de \textit{bits} de cada campo. Como $Al = 26$, $Ax = 17$, $Ay = 8$, $Ac = 2$, $Aq = 0$, $\#l = 6$, $\#x = 9$, $\#y = 9$, $\#c = 6$ e $\#q = 2$, a especificação às quantidades adotadas na modelagem, (\ref{eq:bitstring_set}) é reescrita como em (\ref{eq:bitstring_set_2}).
\begin{equation}
  \begin{cases}
    \chi\big(L(t + 1), X(t), Y(t), C(t), Q(t)\big) = & \chi\big(L(t), X(t), Y(t), C(t), Q(t)\big) \\
    & \gg_{circ}(26) \gg_{arth}(6) \ll_{arth}(6) \\
    & \, \vee \, L(t + 1) \ll_{circ}(26) \\
    \chi\big(L(t), X(t + 1), Y(t), C(t), Q(t)\big) = & \chi\big(L(t), X(t), Y(t), C(t), Q(t)\big) \\
    & \gg_{circ}(17) \gg_{arth}(9) \ll_{arth}(9) \\
    & \, \vee \, X(t + 1) \ll_{circ}(17) \\
    \chi\big(L(t), X(t), Y(t + 1), C(t), Q(t)\big) = & \chi\big(L(t), X(t), Y(t), C(t), Q(t)\big) \\
    & \gg_{circ}(8) \gg_{arth}(9) \ll_{arth}(9) \\ 
    & \, \vee \, Y(t + 1) \ll_{circ}(8) \\
    \chi\big(L(t), X(t), Y(t), C(t + 1), Q(t)\big) = & \chi\big(L(t), X(t), Y(t), C(t), Q(t)\big) \\
    & \gg_{circ}(2) \gg_{arth}(6) \ll_{arth}(6) \\ 
    & \, \vee \, C(t + 1) \ll_{circ}(2) \\
    \chi\big(L(t), X(t), Y(t), C(t), Q(t + 1)\big) = & \chi\big(L(t), X(t), Y(t), C(t), Q(t)\big) \\
    & \gg_{circ}(0) \gg_{arth}(2) \ll_{arth}(2) \\
    & \, \vee \,Q(t + 1) \ll_{circ}(0) \\
  \end{cases}
  \label{eq:bitstring_set_2}
\end{equation}

Considere novamente o agente $\chi(t)$ especificado em (\ref{eq:ex_get_agente}), em que o símbolo $|$ designa o separador dos campos do agente. A aplicação do operador definido em (\ref{eq:bitstring_set_2}) para a configuração do campo do identificador do lote do agente $\chi(t)$ de $L(t)$ para $L(t + 1)$, é exemplificada como ilustrado em (\ref{eq:ex_set_l}), considerando $L(t + 1) = 0 0 1 1 1 1$.

\begin{equation}
  \begin{split}
  \chi(t + 1) = & \chi(t) \gg_{circ}(26) \gg_{arth}(6) \ll_{arth}(6) \, \vee \, L(t + 1) \ll_{circ}(26) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \gg_{circ}(26) \\
    & \gg_{arth}(6) \ll_{arth}(6) \, \vee \, 0 0 1 1 1 1 \ll_{circ}(26) \\
  = & 0 0 1 0 1 0 | 1 0 0 0 1 1 0 0 1 | 0 1 1 0 0 1 1 1 0 | 1 0 1 1 0 1 | 0 0 \gg_{arth}(6) \\
    & \ll_{arth}(6) \, \vee \, 0 0 1 1 1 1 \ll_{circ}(26) \\
  = & 0 0 0 0 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \ll_{arth}(6)  \\
    & \, \vee \, 0 0 1 1 1 1 \ll_{circ}(26) \\
  = & 0 0 1 0 1 0 | 1 0 0 0 1 1 0 0 1 | 0 1 1 0 0 1 1 1 0 | 1 0 0 0 0 0 | 0 0 \, \vee \, 0 0 1 1 1 1 \ll_{circ}(26) \\
  = & 0 0 1 0 1 0 | 1 0 0 0 1 1 0 0 1 | 0 1 1 0 0 1 1 1 0 | 1 0 0 0 1 1 | 1 1 \ll_{circ}(26) \\
  = & 0 0 1 1 1 1 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \\
  \label{eq:ex_set_l}
  \end{split}
\end{equation}

A aplicação do operador definido em (\ref{eq:bitstring_set_2}) para a configuração do campo da coordenada $x$ do lote do agente $\chi(t)$ de $X(t)$ para $X(t + 1)$, é exemplificada como ilustrado em (\ref{eq:ex_set_x}), considerando $X(t + 1) = 1 1 0 0 0 0 1 1 1$.

\begin{equation}
  \begin{split}
  \chi(t + 1) = & \chi(t) \gg_{circ}(17) \gg_{arth}(9) \ll_{arth}(9) \, \vee \, X(t + 1) \ll_{circ}(17) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \gg_{circ}(17) \\
    & \gg_{arth}(9) \ll_{arth}(9) \, \vee \, 1 1 0 0 0 0 1 1 1 \ll_{circ}(17) \\
  = & 0 1 1 0 0 1 | 0 1 1 0 0 1 1 1 0 | 1 0 1 1 0 1 0 0 0 | 0 1 0 1 0 1 | 0 0 \gg_{arth}(9) \\
    & \ll_{arth}(9) \, \vee \, 1 1 0 0 0 0 1 1 1 \ll_{circ}(17) \\
  = & 0 0 0 0 0 0 | 0 0 0 0 1 1 0 0 1 | 0 1 1 0 0 1 1 1 0 | 1 0 1 1 0 1 | 0 0 \ll_{arth}(9) \\
    & \, \vee \, 1 1 0 0 0 0 1 1 1 \ll_{circ}(17) \\
  = & 0 1 1 0 0 1 | 0 1 1 0 0 1 1 1 0 | 1 0 1 1 0 1 0 0 0 | 0 0 0 0 0 0 | 0 0 \, \vee \, 1 1 0 0 0 0 1 1 1 \ll_{circ}(17) \\
  = & 0 1 1 0 0 1 | 0 1 1 0 0 1 1 1 0 | 1 0 1 1 0 1 0 0 1 | 1 0 0 0 0 1 | 1 1 \ll_{circ}(17) \\
  = & 1 1 0 1 0 0 | 1 1 0 0 0 0 1 1 1 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \\
  \label{eq:ex_set_x}
  \end{split}
\end{equation}

A aplicação do operador definido em (\ref{eq:bitstring_set_2}) para a configuração do campo da coordenada $y$ do lote do agente $\chi(t)$ de $Y(t)$ para $Y(t + 1)$, é exemplificada como ilustrado em (\ref{eq:ex_set_y}), considerando $Y(t + 1) = 1 1 1 1 0 1 0 0 0$.

\begin{equation}
  \begin{split}
  \chi(t + 1) = & \chi(t) \gg_{circ}(8) \gg_{arth}(9) \ll_{arth}(9) \, \vee \, Y(t + 1) \ll_{circ}(8) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \gg_{circ}(8) \\
    & \gg_{arth}(9) \ll_{arth}(9) \, \vee \, 1 1 1 1 0 1 0 0 0 \ll_{circ}(8) \\
  = & 0 0 1 1 1 0 | 1 0 1 1 0 1 0 0 0 | 0 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 | 1 1 \gg_{arth}(9) \\
    & \ll_{arth}(9) \, \vee \, 1 1 1 1 0 1 0 0 0 \ll_{circ}(8) \\
  = & 0 0 0 0 0 0 | 0 0 0 0 0 1 1 1 0 | 1 0 1 1 0 1 0 0 0 | 0 1 0 1 0 1 | 0 0 \ll_{arth}(9) \\
    & \, \vee \, 1 1 1 1 0 1 0 0 0 \ll_{circ}(8) \\
  = & 0 0 1 1 1 0 | 1 0 1 1 0 1 0 0 0 | 0 1 0 1 0 1 0 0 0 | 0 0 0 0 0 0 | 0 0 \, \vee \, 1 1 1 1 0 1 0 0 0 \ll_{circ}(8) \\
  = & 0 0 1 1 1 0 | 1 0 1 1 0 1 0 0 0 | 0 1 0 1 0 1 0 0 1 | 1 1 1 0 1 0 | 0 0 \ll_{circ}(8) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 1 1 1 1 0 1 0 0 0 | 0 0 1 1 1 0 | 1 0 \\
  \label{eq:ex_set_y}
  \end{split}
\end{equation}

A aplicação do operador definido em (\ref{eq:bitstring_set_2}) para a configuração do campo do contador de transição de estados do agente $\chi(t)$ de $C(t)$ para $C(t + 1)$, é exemplificada como ilustrado em (\ref{eq:ex_set_c}), considerando $C(t + 1) = 1 0 1 0 1 1$.

\begin{equation}
  \begin{split}
  \chi(t + 1) = & \chi(t) \gg_{circ}(2) \gg_{arth}(6) \ll_{arth}(6) \, \vee \, C(t + 1) \ll_{circ}(2) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \gg_{circ}(2) \\
    & \gg_{arth}(6) \ll_{arth}(6) \, \vee \, 1 0 1 0 1 1 \ll_{circ}(2) \\
  = & 1 0 1 1 0 1 | 0 0 0 0 1 0 1 0 1 | 0 0 0 1 1 0 0 1 0 | 1 1 0 0 1 1 | 1 0 \gg_{arth}(6) \\
    & \ll_{arth}(6) \, \vee \, 1 0 1 0 1 1 \ll_{circ}(2) \\
  = & 0 0 0 0 0 0 | 1 0 1 1 0 1 0 0 0 | 0 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 | 1 1 \ll_{arth}(6) \\
    & \, \vee \, 1 0 1 0 1 1 \ll_{circ}(2) \\
  = & 1 0 1 1 0 1 | 0 0 0 0 1 0 1 0 1 | 0 0 0 1 1 0 0 1 0 | 1 1 0 0 0 0 | 0 0 \, \vee \, 1 0 1 0 1 1 \ll_{circ}(2) \\
  = & 1 0 1 1 0 1 | 0 0 0 0 1 0 1 0 1 | 0 0 0 1 1 0 0 1 0 | 1 1 1 0 1 0 | 1 1 \ll_{circ}(2) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 1 0 1 0 1 1 | 1 0 \\
  \label{eq:ex_set_c}
  \end{split}
\end{equation}

A aplicação do operador definido em (\ref{eq:bitstring_set_2}) para a configuração do campo do estado do agente $\chi(t)$ de $Q(t)$ para $Q(t + 1)$, é exemplificada como ilustrado em (\ref{eq:ex_set_e}), considerando $Q(t + 1) = 0 1$.

\begin{equation}
  \begin{split}
  \chi(t + 1) = & \chi(t) \gg_{circ}(0) \gg_{arth}(2) \ll_{arth}(2) \, \vee \, Q(t + 1) \ll_{circ}(0) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \gg_{circ}(0) \\
    & \gg_{arth}(2) \ll_{arth}(2) \, \vee \, 0 1 \ll_{circ}(0) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \gg_{arth}(2) \\
    & \ll_{arth}(2) \, \vee \, 0 1 \ll_{circ}(0) \\
  = & 0 0 1 1 0 1 | 0 0 0 0 1 0 1 0 1 | 0 0 0 1 1 0 0 1 0 | 1 1 0 0 1 1 | 1 0 \ll_{arth}(2) \\
    & \, \vee \, 0 1 \ll_{circ}(0) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 0 0 \, \vee \, 0 1 \ll_{circ}(0) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 0 1 \ll_{circ}(0) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 0 1 \\
  \label{eq:ex_set_e}
  \end{split}
\end{equation}

Na Tabela \ref{tab:variaveis} são apresentados sinteticamente os valores relativos às quantidades de \textit{bits} dos tamanhos, complementos, posteriores e anteriores de cada atributo do agente $\chi$.

\begin{table}[h!]
\centering
\begin{tabular}{c|c|c|c|c}
  Atributo & Tamanho & Complementar & Posteriores & Anteriores \\ \hline
  Identificador do Lote $L$ 	& 6 & 26 & 0 & 26 \\
  Coordenada $X$ 		& 9 & 23 & 6 & 17 \\
  Coordenada $Y$ 		& 9 & 23 & 15 & 8 \\
  Contador de Controle $C$ 	& 6 & 26 & 24 & 2 \\
  Estado $Q$ 			& 2 & 30 & 30 & 0 \\
\end{tabular}
\caption{Tabela das variáveis relacionadas aos campos dos agentes.}
\label{tab:variaveis}
\end{table}

Para completar a modelagem é suficiente detalhar e relacionar os identificadores dos lotes e dimensões dos lotes, a faixa de variação do controle, e os possíveis tipos de estados do agente na base $10$, com tais características na base $2$, para determinar sem ambiguidade os elementos de (\ref{especificacaoAgente}). 

Os identificadores dos lotes têm variação de $\big(0\big)_{10} = \big(000\ 000\big)_{2}$ até $\big(63\big)_{10} = \big(111\ 111\big)_{2}$, totalizando $64$ possíveis valores. Os lotes têm dimensão máxima de $512_{10} = 2^{9}$ linhas por $512_{10} = 2^{9}$ colunas, sendo possível variarem numa representação matricial da posição $\big(0; 0\big)_{10} = \big(000\ 000\ 000; 000\ 000\ 000\big)_{2}$ até a posição $\big(511; 511\big)_{10} = \big(111\ 111\ 111; 111\ 111\ 111\big)_{2}$, totalizando os $512$ possíveis valores. Semelhantemente, faz-se uma representação matricial ao controle para que sua variação ocorra de $\big(0\big)_{10} = \big(000\ 000\big)_{2}$ até $\big(63\big)_{10} = \big(111\ 111\big)_{2}$, totalizando os $64$ possíveis valores. Os estados do agente são setados como $\big(0, 0\big)_{2}$ para o suscetível, $S$, $\big(0, 1\big)_{2}$ para o exposto, $E$, $\big(1, 0\big)_{2}$ para o infectante, $I$, e $\big(1, 1\big)_{2}$ para o recuperado, $R$.

\section{SIMULA}
\label{sec:SIMULA}

Como suporte às operações específicas relacionadas à manipulação de dados georreferenciados relativos às quadras utilizou-se um \textit{software} especificamente desenvolvido para tal função, denominado SIMULA. Ele desempenha as funções de aquisição, tratamento e disponibilização de informações georreferenciadas para o programa que executa as simulações e para um módulo visualizador de saídas, sendo um \textit{software} que integra operações de pré-processamento, como aquisição e tratamento de dados e de pós-processamento, como a visualização de saídas gráficas de arquivos resultantes das simulações executadas.

Na etapa de aquisição dos dados, o \textit{software} realiza uma consulta em um Sistema Gerenciador de Banco de Dados Objeto Relacional, SGBDOR, utilizando a linguagem de consulta \textit{Structured Query Language}, SQL \cite{SQL}. Nesta etapa são obtidas informações sobre os pontos georreferenciados que estão nos vértices de cada lote das quadras. As informações sobre os vértices são importantes pois definem a geometria do lote, que é a estrutura geométrica elementar à especificação das soluções, sendo utilizados posteriormente, após processamentos, à construção das estruturas matriciais que representam os lotes na simulação. Foi utilizado o SGBDOR PostgreSQL \cite{Postgres} com a adição da extensão PostGIS \cite{Postgis}, que viabiliza o armazenamento e processamento de objetos com informações georreferenciadas em bancos de dados. Por meio da extensão PostGIS, os dados são importados para o banco de dados por meio de um arquivo em formato \textit{shapefile} \cite{Shapefile}, que é um formato de arquivos utilizado para o armazenamento de dados geoespaciais. O arquivo \textit{shapefile} foi obtido em parceria com a prefeitura da cidade de Cascavel/PR.

Na etapa posterior à aquisição ocorre o tratamento dos dados obtidos, que é necessário para a remoção de informações redundantes que vem do banco de dados, e a adição de informações pertinentes que viabilizem, essencialmente, a aproximação da geometria dos lotes em matrizes bidimensionais. As principais processos executados dentro da etapa de tratamento de dados são:
\begin{itemize}
 \item \textbf{Limpeza de pontos:} São removidos os pontos duplicados ou pontos que estejam muito próximos uns dos outros, utilizando como critério de remoção os erros relativos entre as latitudes e longitudes dos pontos. 
 \item \textbf{Inserção de pontos:} É inserido um ponto adicional ao conjunto de pontos de um lote que contenha exatamente 6 pontos. Essa inserção de um ponto adicional é essencial para a realização correta da etapa de divisão de lotes.
 \item \textbf{Ordenação de pontos:} Os pontos são ordenados, em sentido horário, com início no ponto com menor latitude e maior longitude. A ordenação dos pontos é importante para a determinação do local apropriado à divisão de um lote.
 \item \textbf{Divisão de lotes:} É realizada a divisão de lotes que contenham 7 pontos, em dois outros sub-lotes. A divisão é executada por meio do cruzamento das diversas retas formadas por dois pontos quaisquer do conjunto original de pontos, com o intuito de formar dois polígonos regulares, que gerarão os dois novos lotes.
 \item \textbf{Cálculo das dimensões dos lotes:} São calculados o comprimento e largura dos lotes, a partir das distâncias euclidianas dos pontos que estão nos vértices dos lotes.
 \item \textbf{Interpolação de pontos:} Por meio de interpolação linear, são interpolados os pontos entre os vértices, que formam as arestas dos lotes. Por meio dos pontos das arestas dos lotes, são interpolados linearmente os pontos internos ao lote. A interpolação é um processo importante no tratamento dos dados pois viabiliza a aproximação de uma malha que represente a geometria do lote, por meio de seus vértices.
 \item \textbf{Média de pontos:} São calculadas as médias entre subconjuntos de 4 pontos do conjunto de pontos obtidos da malha gerada pela etapa de interpolação de pontos. O processo realizado assemelha-se a uma convolução com máscaras, utilizando uma máscara de dimensão $2 \times 2$, com todos os coeficientes iguais a 1, e uma constante de normalização igual a $\frac{1}{4}$. Como resultado, obtém-se um conjunto de pontos em que, cada ponto, corresponde ao centro de uma posição na matriz do lote.
 \item \textbf{Cálculo das dimensões das matrizes:} Por meio dos pontos obtidos na etapa anterior são calculadas as dimensões das matrizes que representarão os lotes na simulação. Efetivamente, são calculadas as quantidades de linhas e de colunas das matrizes.
\end{itemize}

Durante o tratamento dos dados ocorre ainda o cálculo das posições vizinhas entre as fronteiras de cada lote. Durante este processo, para cada lote, calculam-se as posições vizinhas em outro lote para cada posição que está em sua fronteira, por meio de algoritmos especialmente desenvolvidos, o que possibilita que, os indivíduos, durante a operação de movimentação, desloquem-se de um lote para outro, se estiverem em uma posição de fronteira que possua posições vizinhas em um lote adjacente. Neste processo, os algoritmos necessitam apenas das quantidades de linhas e colunas de cada lote e as posições relativas entre os lotes. As informações sobre as posições relativas entre os lotes são lidas pelo SIMULA de um arquivo de configuração à parte, que foi gerado manualmente. Neste arquivo constam efetivamente as vizinhanças entre os lotes, informando para cada lote, quais lotes estão em sua vizinhança e quais são as posições relativas entre eles. Estes algoritmos utilizam as informações de vizinhanças entre lotes para determinar qual método utilizar no cálculo das vizinhanças entre posições dos lotes: método de linhas, método de colunas ou método de canto. O método de linha é utilizado em vizinhanças horizontais, em que os pontos centrais dos lotes têm longitudes aproximadas e latitudes distantes. O método de colunas é utilizado em vizinhanças verticais, em que os pontos centrais dos lotes têm latitudes aproximadas e longitudes distantes. O método de canto é utilizado em vizinhanças em que os pontos centrais dos lotes têm latitudes e longitudes distantes. Após determinado o método, o algoritmo percorre todas as posições de fronteira do lote, calculando suas posições vizinhas nos lotes vizinhos, utilizando as informações sobre a quantidade de linhas e de colunas das matrizes dos lotes. Após o cálculo das vizinhanças, um arquivo texto é gerado e disponibilizado para a sistema de simulação, que irá realizar a leitura dos dados e construir a estrutura de vizinhança que é utilizada durante as simulações. 

Na operação de processamento são executadas efetivamente as simulações. Após a geração de diversos arquivos de configuração, o \textit{software} SIMULA executa o sistema de simulação, que realiza a leitura dos arquivos gerados e executa as simulações solicitadas. Ao final de cada simulação, o sistema de simulação gera arquivos texto de saída, que são utilizados pelo SIMULA para exibição de saídas gráficas na etapa de pós-processamento. É importante notar que, o sistema de simulação é independente ao \textit{software} SIMULA, podendo ser utilizado separadamente, sendo necessário a geração ou cópia manual dos arquivos de entrada e algum meio independente para geração de saídas gráficas. Efetivamente, quando na execução dos experimentos numérico-computacionais, o sistema de simulação é utilizado separadamente ao SIMULA, por questões de simplicidade na execução de uma grande quantidade de simulações com diferentes parâmetros. 

Na operação de pós-processamento, os arquivos de saída gerados pelo sistema de simulação são utilizados para a visualização gráfica dos resultados no \textit{software} SIMULA. A Figura \ref{fig:simula1} ilustra a saída espacial obtida por meio da utilização das informações georreferenciadas da quadra 445, em que os indivíduos em azul representam indivíduos em estado suscetível, em amarelo representam indivíduos em estado latente, em vermelho representam indivíduos em estado infectado e em rosa representam indivíduos em estado recuperado. Esta visualização georreferenciada foi concebida e desenvolvida com base em aprimoramentos dos trabalhos realizados em \cite{TCCDaniel}.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.9\textwidth]{Figuras/Simula1.PNG}
  \caption{Ilustração da saída espacial na quadra 445 gerada pelo SIMULA}
  \label{fig:simula1}
\end{figure} 

A Figura \ref{fig:simula2} ilustra outro tipo de saída gráfica gerada pelo \textit{software} SIMULA, os gráficos de curvas, que representam as quantidades de cada tipo de indivíduo durante o tempo de simulação. A linha em verde indica a quantidade de indivíduos em estado suscetível, em amarelo indica a quantidade de indivíduos em estado latente, em vermelho indica a quantidade de indivíduos em estado infectado e em azul indica a quantidade de indivíduos em estado recuperado. 

\newpage

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.85\textwidth]{Figuras/Simula2.PNG}
  \caption{Ilustração do gráfico de linha gerado pelo SIMULA}
  \label{fig:simula2}
\end{figure} 

A Figura \ref{fig:simula3} ilustra um terceiro tipo de saída gráfica gerada pelo \textit{software} SIMULA, as saídas de espalhamento das populações em determinados lotes. Esta saída apresenta a distribuição espacial das diferentes populações nos lotes de acordo com o tempo. Graficamente, é exibida uma matriz com dimensões idênticas à de determinado lote, em que cada posição é exibida de uma cor, dependendo dos estados dos indivíduos que a ocupam. Uma posição em cor verde indica que nesta posição existem somente indivíduos em estado suscetível, em cor amarela indica que existem indivíduos em estado latente e podem ou não existir indivíduos em estado suscetível, em cor vermelha indica que existem indivíduos em estado infectado e podem ou não existirem indivíduos em estado latente e suscetível, em cor azul indica que existem indivíduos em estado recuperado e podem ou não existirem indivíduos em estado infectado, latente e suscetível e em cor branca indica que não existem indivíduos ocupando tal posição. Cada ciclo da simulação gera uma matriz para cada lote, que é utilizado para compor esta saída. 

\newpage

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.85\textwidth]{Figuras/Simula3.PNG}
  \caption{Ilustração da saída espalhamento em um lote}
  \label{fig:simula3}
\end{figure} 

Na Figura \ref{fig:fluxo_simula} são ilustradas as etapas descritas anteriormente e sua ordem de execução, contemplando o pré-processamento, processamento e pós-processamento.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.9\textwidth]{Figuras/FluxoSIMULA.eps}
  \caption{Fluxograma da execução completa do SIMULA.}
  \label{fig:fluxo_simula}
\end{figure} 

\newpage

\section{Estruturas de Dados e Estratégias de Implementação}
\label{sec:estruturasdedados}

Para a implementação do sistema de simulação, mais efetivamente às operações de movimentação, contato e transição de estados dos indivíduos, utilizou-se estruturas de dados puramente vetoriais, ou seja, que são armazenadas em espaços de memória contíguos na memória do computador. A motivação do uso de estruturas vetoriais advém do fato de que reduzem a complexidade estrutural no código-fonte e viabilizam a posterior paralelização em CUDA por facilitar a cópia de dados entre a CPU e a GPU. Estruturas dinâmicas complexas, que suportam quantidades variáveis de elementos e garantem maior flexibilidade ao programador, são de difícil trato às operações de cópia de dados entre dispositivos, pois necessitam de métodos específicos para a serialização e a desserialização de dados, que acarretam em aumento na carga de processamento. A vetorização das estruturas de dados foi possível graças à simplicidade do indivíduo e do ambiente modelado na simulação, em que é possível expressar completamente seu significado por meio de vetores de tipo homogêneo e com quantidade fixa de elementos. 

Quanto à estrutura matricial utilizada à representação dos lotes da quadra 445, todos os lotes representados na simulação armazenam, em cada posição de sua matriz, um vetor contendo os índices de todos os indivíduos que ocupam esta posição. Cada indivíduo tem um índice único, que corresponde à sua posição no vetor que armazena todos os indivíduos. Assim, embora as estruturas dos lotes são referidas como matrizes bidimensionais ou tridimensionais, efetivamente, na implementação realizada, estas estruturas são decompostas em vetores unidimensionais, sendo citadas como matrizes somente com o intuito de facilitar a compreensão em alto nível da estrutura da quadra e de seus lotes, já que o mapeamento geográfico ao lógico assim foi realizado. Os estudos desenvolvidos durante a escrita de \cite{Meditec} serviram como base à definição da estrutura dos lotes da quadra 445, pois o armazenamento dos indivíduos que ocupam cada posição do lote na própria estrutura do lote, é um fator importante na otimização do processamento necessário nas operações de movimentação e de contato entre indivíduos. A Figura \ref{fig:ambiente1} ilustra um exemplo da estrutura aplicada a cada lote modelado neste trabalho, em que as hipotéticas posições do ambiente, mostradas nas cores verde e azul, armazenam vetores com os índices de todos os indivíduos que a ocupam. Os índices desses vetores são utilizados para acessar diretamente os indivíduos no vetor global de agentes.

\newpage

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.65\textwidth]{Figuras/ambiente1.png}
  \caption{Ilustração da estrutura matricial empregada para a representação do mapeamento lógico dos lotes}
  \label{fig:ambiente1}
\end{figure} 

As alterações que precisam ser realizadas, em termos de estruturas de dados, de uma implementação convencional à \textit{bitstring} são mínimas. Em uma implementação convencional, utilizando o paradigma de programação orientada à objetos, utilizam-se classes para armazenar os atributos dos indivíduos e métodos que manipulam esses atributos. Assim, para armazenar todos os indivíduos em memória, é necessário utilizar um vetor de classes. Quando da aplicação da técnica de \textit{bitstring}, substituem-se essas classes por um tipo de dado primitivo da linguagem de programação em uso. 

Neste trabalho adotou-se a linguagem de programação C e seu tipo primitivo para números inteiros \textit{int}. Assim, esse tipo primitivo é utilizado para armazenar efetivamente os atributos dos indivíduos e funções externas à estrutura do indivíduo são definidas para manipular seus atributos, decorrendo que, para o armazenamento de todos os indivíduos, é necessário apenas um vetor de inteiros ao invés de um vetor de classes. As funções externas necessárias para manipular os atributos dos indivíduos sobre o tipo de dado primitivo são aquelas definidas na seção \ref{sec:modelagembitstring}. Essa funções ou operações, quando na aplicação da técnica \textit{bitstring}, equivalem-se a definição de métodos \textit{get} e \textit{set} na classe que representa o indivíduo, considerando-se o uso do paradigma de programação orientada à objetos.

Os algoritmos 1, 2 e 3 ilustram os pseudo-códigos em alto nível às operações de movimentação, contato e transição de estados dos indivíduos, que foram efetivamente implementados no sistema de simulação. É importante perceber que, os pseudo-códigos apresentados podem ser utilizados tanto para realizar uma implementação convencional, utilizando o paradigma de programação orientada à objetos, quanto para implementar uma versão utilizando a técnica de \textit{bitstring}, pois, quando da definição dos métodos para manipulação dos atributos dos indivíduos, seja ela interna ou externamente à uma classe, os resultados produzidos por essas operações, são equivalentes. 

\begin{algorithm}[H]
   \SetAlgoLined   
   \Inicio{
	\Para{cada indivíduo na simulação} {
	      direção = randomiza\_um\_número\_inteiro\_entre(0, 8) \\
	      \Se{direção $= 0$} {
		      subtrai\_um\_coordenada\_x(indivíduo)
	      }
	      \Se{direção $= 1$} {
		      soma\_um\_coordenada\_x(indivíduo)
	      }
	      \Se{direção $= 2$} {
		      subtrai\_um\_coordenada\_y(indivíduo)
	      }
	      \Se{direção $= 3$} {
		      soma\_um\_coordenada\_y(indivíduo)
	      }
	      \Se{direção $= 4$} {
		      subtrai\_um\_coordenada\_x(indivíduo) \\
		      subtrai\_um\_coordenada\_y(indivíduo)
	      }
	      \Se{direção $= 5$} {
		      subtrai\_um\_coordenada\_x(indivíduo) \\
		      soma\_um\_coordenada\_y(indivíduo)
	      }
	      \Se{direção $= 6$} {
		      soma\_um\_coordenada\_x(indivíduo) \\
		      subtrai\_um\_coordenada\_y(indivíduo)
	      }
	      \Se{direção $= 7$} {
		      soma\_um\_coordenada\_x(indivíduo) \\
		      soma\_um\_coordenada\_y(indivíduo)
	      }
	      \Se{direção $= 8$} {
		      \Se{posição(indivíduo) tem vizinhos em outro lote} {
			      move\_individuo\_para\_posição\_vizinha\_aleatória()
		      }
	      }
	} 
   }
   \label{alg:movimentacao}
   \caption{\textsc{Movimentação dos indivíduos}}
\end{algorithm}

\begin{algorithm}
 \SetAlgoLined  
 \Inicio{
    \Para{cada lote $k$ da quadra} {
	\Para{cada posição $(x, y)$ do lote $k$} {
	    \Se{posição $(x, y)$ contém indivíduos infectados} {
	        \Para{cada indivíduo suscetível na posição $(x, y)$} {
		    \Se{percentual\_randômico $\leq \beta$} {
		        altera\_estado\_do\_indivíduo\_para\_exposto()
		    }
		}
	    }
	}
    }
 }
 \label{alg:contato}
 \caption{\textsc{Contato entre indivíduos}} 
\end{algorithm}

\begin{algorithm}
 \SetAlgoLined  
  \Para{cada indivíduo na simulação} {
        \Se{indivíduo está em estado exposto} {
                \eSe{contador de períodos do indivíduo $\geq \gamma$} {
                        altera\_estado\_do\_indivíduo\_para\_infectado() \\
                        zera\_contador\_de\_períodos\_do\_indivíduo()
                } {
                        soma\_um\_contador\_de\_períodos\_do\_indivíduo()
                }
        }
        \Se{indivíduo está em estado infectado} {
                \eSe{contador de períodos do indivíduo $\geq \alpha$} {
                        altera\_estado\_do\_indivíduo\_para\_recuperado() \\
                        zera\_contador\_de\_períodos\_do\_indivíduo()
                } {
                        soma\_um\_contador\_de\_períodos\_do\_indivíduo()
                }
        }
        \Se{indivíduo está em estado recuperado} {
                \eSe{contador de períodos do indivíduo $\geq \delta$} {
                        altera\_estado\_do\_indivíduo\_para\_suscetível() \\
                        zera\_contador\_de\_períodos\_do\_indivíduo()
                } {
                        soma\_um\_contador\_de\_períodos\_do\_indivíduo() \\
                }
        }
  }
 \label{alg:transicao}
 \caption{\textsc{Transição de estados dos indivíduos}} 
\end{algorithm}

\newpage

As Figuras \ref{fig:fluxo_movimentacao}, \ref{fig:fluxo_contato} e \ref{fig:fluxo_transicao} ilustram fluxogramas para as operações de movimentação, contato e transição de estados dos indivíduos, respectivamente.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.30\textwidth]{Figuras/FluxoMovimentacao.eps}
  \caption{Fluxograma para a operação de movimentação dos indivíduos.}
  \label{fig:fluxo_movimentacao}
\end{figure} 

\begin{figure}[!htb]
  \centering
  \includegraphics[width=1\textwidth]{Figuras/FluxoContato.eps}
  \caption{Fluxograma para a operação de contato entre os indivíduos.}
  \label{fig:fluxo_contato}
\end{figure} 

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.80\textwidth]{Figuras/FluxoTransicao.eps}
  \caption{Fluxograma para a operação de transição de estados dos indivíduos.}
  \label{fig:fluxo_transicao}
\end{figure} 

\newpage
