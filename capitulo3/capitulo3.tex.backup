\chapter{Metodologias Computacionais}
\label{CapMetodologiasComputacionais}

\section{Introdução}
\label{sec:intro3}

Neste capítulo serão apresentadas as metodologias computacionais utilizadas à realização deste trabalho. Serão discutidas as modelagens realizadas à representação do ambiente e dos indivíduos no sistema multiagente proposto, expondo-as em termos de operadores e ao uso da metodologia em \textit{bitstring}, as linguagens de programação e as motivações de seus usos, as estruturas de dados desenvolvidas à apropriada aplicação da modelagem \textit{bitstring} e paralelização em CUDA e estratégias de implementação do sistema multiagente. Em sequência serão discutidas questões relativas às APIs para programação paralela OpenMP e CUDA, discutindo suas principais características e aplicações. Por fim será apresentado o \textit{software} especialmente desenvolvido à manipulação de informações georreferenciadas, que será utilizado como apoio às operações de configuração de parâmetros e do ambiente e à visualização de resultados das simulações que serão executadas.

\section{Modelagem do Ambiente de Simulação}
\label{sec:modelagemAmbiente}

Para a modelagem do ambiente computacional, que servirá à execução de simulações da dinâmica epidemiológica, será utilizada como base uma região geográfica da cidade de Cascavel/PR, mais especificamente a quadra 445. A quadra 445 está localizada no centro da cidade de Cascavel/PR e é delimitada geograficamente pelas ruas Maranhão, Castro Alves, Curitiba e Visconde de Guarapuava. Esta quadra foi escolhida por ser um bom modelo geométrico, com relação às outras quadras da cidade, o que é interessante para desenvolver as estruturas de dados utilizadas na implementação do \textit{software}. A Figura \ref{fig:q445} ilustra a quadra em questão.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.8\textwidth]{Figuras/Q445.png}
  \caption{Representação gráfica da quadra 445.}
  \label{fig:q445}
\end{figure} 

A quadra 445 contém 15 lotes, sendo necessário mapear cada um destes para uma estrutura matricial que viabilize sua representação e implementação no sistema de simulação. Para tanto, os lotes 0002 e 019B são divididos em outros dois lotes, pois apresentam geometria irregular de difícil aproximação em estruturas matriciais. Essa divisão é realizada de tal forma que as matrizes resultantes representam, aproximadamente, a geometria original do lote dividido. Aos outros lotes da quadra 445 não serão aplicadas nenhuma operação adicional, por apresentarem geometria regular, que pode ser facilmente aproximada por matrizes. Com as operações de divisão dos lotes irregulares, a quadra 445 que originalmente contém 15 lotes, é mapeada sobre um conjunto com 17 estruturas matriciais, que representam os lotes de forma apropriada à sua implementação computacional.

Como os lotes da quadra 445 serão mapeados para estruturas matriciais que viabilizam sua implementação em linguagens de programação, à cada lote estará associada, no sistema de simulação, uma matriz de $n$ linhas e $m$ colunas, que representa sua região física. Essa especificação é importante pois à modelagem dos agentes é necessária a descrição do ambiente em que se movem e habitam. Cada agente terá uma determinada posição na quadra, que é completamente especificada pelas coordenadas $x$ e $y$ da matriz do lote e por um identificador do lote em que o agente se encontra. As coordenadas $x$ e $y$ representarão, respectivamente, a linha e coluna da matriz do lote em que o agente está localizado. 

À modelagem das vizinhanças de uma determinada posição $(x, y)$ de um lote qualquer, será utilizada a vizinhança de Moore, que é amplamente usada na modelagem de autômatos celulares. A Figura \ref{fig:moore} ilustra gráficamente os incrementos locais que são realizados às coordenadas de uma posição qualquer para a obtenção de sua vizinhança de Moore.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.25\textwidth]{Figuras/Vizinhanca_Moore.png}
  \caption{Representação indicial e local da vizinhança de Moore.}
  \label{fig:moore}
\end{figure} 

Assim sendo, do ponto de vista posicional, a vizinhança de Moore de uma posição $(x, y)$ qualquer consiste no conjunto das posições $(x, y + 1)$, $(x, y - 1)$, $(x + 1, y)$, $(x + 1, y + 1)$, $(x + 1, y - 1)$, $(x - 1, y)$, $(x - 1, y + 1)$ e $(x - 1, y - 1)$. A definição das vizinhanças de um determinada posição de um lote é relevante às operações de movimentação dos agentes da população, em que ocorre a simulação. 

\section{Modelagem em Operadores aos Agentes}
\label{sec:modelagemoperadores}

Os modelos apresentados na Seção \ref{sec:modeloscompartimentais} serviram à fundamentação do modelo baseado em agentes, que será desenvolvido e utilizado na implementação e execução de simulações computacionais. A modelagem empregada para simular o espalhamento de hipotética doença de transmissão direta em indivíduos considera agentes baseados em modelos que são definidos espaço-temporalmente especificando-se como ocorre a transição do seu estado num intervalo de tempo e seu movimento no ambiente, de uma posição para outra no passo de tempo. Um passo de tempo é especificado como um ciclo de transição.

Um agente $\chi(t)$ é definido espaço-temporalmente especificando-se como ocorre a transição do seu estado num intervalo de tempo $t$ e seu movimento no espaço, que é o ambiente computacional em que o agente é especificado. O estado do agente é especificado por meio do conjunto de atributos, como apresentado em (\ref{especificacaoAgente}).
\begin{equation}
\label{especificacaoAgente}
 \chi(t) \equiv (L, X, Y, C, E)
\end{equation}
cujos significados dos identificadores dos atributos do estado interno do agente $\chi(t)$ são como:

\begin{itemize}
 \item Lote, $L$: Identificador do lote que o agente $\chi(t)$ se encontra.
 \item Posição em x, $X$: Coordenada $x$ da posição do agente $\chi(t)$ no lote.
 \item Posição em y, $Y$: Coordenada $y$ da posição do agente $\chi(t)$ no lote.
 \item Contador de controle, $C$: Contador de ciclos que controla os períodos de transição entre os estados do agente.
 \item Estado, $E$: Identificador do estado atual do agente $\chi(t)$.
\end{itemize}

A especificação formal de um agente é realizada por meio de um operador de evolução que define o estado atual do agente, quando interagindo com o ambiente. Esse operador decorre da composição entre os operadores de transição temporal, que realiza uma transição do estado interno do agente considerando-se sua interação com outros agentes e com o ambiente, e o operador de transição espacial, que movimenta o agente de sua posição para outra, considerando-se os atributos de conectividade e mobilidade. À dinâmica do agente são considerados três tipos de operações:

\begin{itemize}
 \item \textbf{Movimentação:} Nas operações de movimentação, os agentes são movimentados dentro de um ambiente virtual com topologia matricial por meio de suas vizinhanças de Moore às posições escolhidas aleatoriamente, respeitando-se os limites do ambiente.
 \item \textbf{Contato:} Nas operações de contato ocorre, probabilisticamente, a transmissão da doença por meio dos agentes infectados para os agentes suscetíveis que ocupam uma mesma posição no ambiente.
 \item \textbf{Transição de estados:} Nas transições de estados, ocorre a passagem de estados dos agentes de expostos para infectantes, de infectantes para recuperados e de recuperados para suscetíveis.
\end{itemize}

Tais operações são realizadas na sequência em que foram apresentadas e uma vez a cada ciclo, que consiste na aplicação dos operadores sobre a população de agentes e geração de arquivos de saída. Uma simulação é composta por uma determinada quantidade de ciclos.

Cada agente implementa uma operação de evolução $\lambda$ que atualiza o estado atual do agente quando interagindo com o ambiente, definido como $\lambda\big(\chi(t)\big)$, que decorre da composição entre os operadores $\mu$ e $\sigma$. O operador de transição espacial, $\mu$, movimenta o agente de sua posição considerando-se os atributos de conectividade e mobilidade, e o operador de transição temporal $\sigma$ realiza a transição do estado interno do agente considerando-se sua interação com outros agentes e o ambiente. O operador de evolução $\lambda$ é definido como em (\ref{operador}).
\begin{equation}
  \label{operador}
  \lambda\big(\chi(t)^{(x, y)}\big) \equiv  \sigma\Big(\mu\big(\chi(t + 1)\big)^{(\xi, \eta)}\Big)
\end{equation}

Assim sendo, o operador espaço-temporal $\lambda\big(\chi(t)\big)$ realiza as operações do agente $\chi(t)$ movimentando-o da posição $(x, y)$ para uma posição $\big(\xi, \eta\big)$ no ciclo de tempo atual, $t$, para o ciclo de tempo, $t+1$.

\section{Modelagem em \textit{Bitstring} aos Agentes}
\label{sec:modelagembitstring}

A modelagem \textit{bitstring} realizada à representação do agente é baseada na manipulação diretas dos \textit{bits} em uma palavra computacional, que é capaz de caracterizar sem ambigüidade a especificação do agente $\chi(t)=\big(L, X, Y, C, E\big)$, com identificador do lote, $L$, coordenada $x$ da posição, $X$, coordenada $y$ da posição, $Y$, contador de controle, $C$, e estado, $E$.

Ao emprego de um modelo em \textit{bitstring} é necessário utilizar uma linguagem de programação que dê suporte apropriado às operações diretas com \textit{bits}. À implementação do sistema multiagente, visando alcançar os objetivos definidos neste trabalho, é proposta a utilização da linguagem de programação C, que provê suporte aos propósitos de modelagem e paralelização do sistema. O tipo de dado inteiro em C, \textit{int}, contém $32$ \textit{bits}, sendo suficiente à especificação da formulação para o agente $\chi(t)$ em termos de quantidade de \textit{bits}, como realizado a seguir.

À identificação do lote atual, $L$, do agente, considera-se que o identificador não ultrapasse $64$ valores, de modo que se supõe que uma quadra contenha no máximo $64$ lotes. À modelagem da posição $X, Y$ de um agente, considera-se que as quantidades de linhas, $\# L$, e de colunas, $\# C$, do ambiente, são limitadas por $max\big(\# L \times \# C\big)=\big(512 \times 512\big)$, em que $max$ indica o máximo possível de linhas e de colunas que podem ser alocadas à essa escolha, considerando-se que uma aproximação matricial de um lote de uma quadra resulta em uma matriz de no máximo $512 \times 512$ posições. À modelagem do contador de controle, $C$, de um agente, considera-se que a quantidade de ciclos em que um agente fica no estado exposto, infectado ou recuperado, não ultrapassem $64$ ciclos de simulação, pois supõe-se que a doença hipotética modelada não tem períodos de transição superior à esse valor. À modelagem do estado $E$ de um agente, considerando a adoção do modelo compartimental tipo SEIRS, existem somente quatro distintos estados.

Assim sendo, observe que $512_{10} = 2^{9}$, $64_{10} = 2^{6}$ e $4_{10} = 2^{2}$, sendo suficiente uma palavra que comporte um quantidade de $32$ \textit{bits} para armazenar a especificação do agente $\chi(t)=\big(L, X, Y, C, E\big)$ em \textit{bits}. A utilização de faixas maiores à representação dos atributos de um agente demandaria outros tipos de dados em C, com maior quantidade de \textit{bits}. A representação da palavra computacional proposta à modelagem dos agentes é como ilustrado na Figura \ref{fig:modelo_bitstring}, sendo que os elementos $l_i \in L$, $x_i \in X$, $y_i \in Y$, $c_i \in C$ e $e_i \in E$ possuem o valor $0$ ou $1$ e seus índices subscritos indicam que cada \textit{bit} pode variar nos respectivos intervalos que estão especificados.
\begin{figure}[!htb]
  \centering
  \includegraphics[width=1.0\textwidth]{Figuras/Tira.eps}
  \caption{Representação \textit{bitstring} do agente $\chi$.}
  \label{fig:modelo_bitstring}
\end{figure} 

Na Figura \ref{fig:modelo_bitstring}, os elementos do identificador do lote $L$ estão nas posições $31$ a $26$. Os elementos das coordenadas $X$ e $Y$ da posição do agente no lote estão nas posições $25$ a $17$ e $16$ a $8$, respectivamente. Os elementos do contador de controle, $C$, e do estado, $E$, estão nas posições $7$ a $2$ e $1$ a $0$, respectivamente. Considerando as escolhas realizadas à sua modelagem, um agente qualquer do modelo pode ser representado em \textit{bits} como em (\ref{eq:bitstring}).
\begin{equation}
 \chi\big(L, X, Y, C, E\big) \equiv \big(l_{31}, \dotsc, l_{26}; x_{25}, \dotsc, x_{17}; y_{16}, \dotsc, y_{8}; c_{7}, \dotsc, c_{2}; e_{1}, \dotsc, e_{0}\big)
 \label{eq:bitstring}
\end{equation}

Para identificar o lote e as coordenadas da posição do agente $\chi\big(L, X, Y, C, E\big) = \chi(t)$ no ambiente, assim como seu estado interno e o registro de controle de ciclos às transições de estados, essas características são definidas como em (\ref{eq:bitstring_get}), para o ciclo $t$, em que $Pl$, $Px$, $Py$, $Pc$ e $Pe$ designam, respectivamente, as quantidades de \textit{bits} posteriores à cada campo.
\begin{equation}
  \begin{cases}
    L(t) = \chi\big(L, X, Y, C, E\big) \ll_{arth}(Pl) \gg_{arth}(C\#l) \\
    X(t) = \chi\big(L, X, Y, C, E\big) \ll_{arth}(Px) \gg_{arth}(C\#x) \\
    Y(t) = \chi\big(L, X, Y, C, E\big) \ll_{arth}(Py) \gg_{arth}(C\#y) \\
    C(t) = \chi\big(L, X, Y, C, E\big) \ll_{arth}(Pc) \gg_{arth}(C\#c) \\
    E(t) = \chi\big(L, X, Y, C, E\big) \ll_{arth}(Pe) \gg_{arth}(C\#e) \\
  \end{cases}
  \label{eq:bitstring_get}
\end{equation}

A quantidade de \textit{bits} posteriores à cada campo é a quantidade de \textit{bits} existentes que são mais significativos àqueles do campo em questão. Os termos $C\#l$, $C\#x$, $C\#y$, $C\#c$ e $C\#e$ designam, respectivamente, as quantidades de \textit{bits} complementares à cada campo. A quantidade de \textit{bits} complementares à cada campo é a diferença entre a quantidade de \textit{bits} total da palavra e a quantidade de \textit{bits} do campo. As operações $\ll_{arth}$ e $\gg_{arth}$ designam, respectivamente, deslocamentos não circulares à esquerda e à direita na palavra, na quantidade de \textit{bits} indicado. As notações $\ll_{arth}$ e $\gg_{arth}$ advém daquelas nomenclaturas utilizadas na linguagem C para designar as operações de deslocamento ou \textit{shift} como deslocamentos aritméticos. 

Em deslocamentos aritméticos, como aqueles que são definidos na linguagem C, ocorre a prevervação do \textit{bit} de sinal, quando da sua execução no sentido esquerda-direita. Deslocamentos que não preservam o \textit{bit} de sinal são chamados deslocamentos lógicos, que não são definidos na linguagem C. O uso do tipo de dado \textit{unsigned int} descarta a preservação de sinal na realização de \textit{shifts} ou deslocamentos, evitando a introdução de erro na manipulação dos \textit{bits} mais significativos em operações de captura e configuração de atributos de um agente, viabilizando o uso de deslocamentos aritméticos com o mesmo resultado prático obtido por deslocamentos lógicos, sendo o uso do tipo \textit{unsigned int} é justificado por este motivo.

Na modelagem realizada, as especificações às quantidades são $Pl = 0$, $Px = 6$, $Py = 15$, $Pc = 24$, $Pe = 30$, $C\#l = 26$, $C\#x = 23$, $C\#y = 23$, $C\#c = 26$ e $C\#e = 30$, de modo que (\ref{eq:bitstring_get}) é então reescrita concretamente para a modelagem (\ref{eq:bitstring}) como em (\ref{eq:bitstring_get_2}).
\begin{equation}
  \begin{cases}
    L(t) = \chi\big(L, X, Y, C, E\big) \ll_{arth}(0) \gg_{arth}(26) \\
    X(t) = \chi\big(L, X, Y, C, E\big) \ll_{arth}(6) \gg_{arth}(23) \\
    Y(t) = \chi\big(L, X, Y, C, E\big) \ll_{arth}(15) \gg_{arth}(23) \\
    C(t) = \chi\big(L, X, Y, C, E\big) \ll_{arth}(24) \gg_{arth}(26) \\
    E(t) = \chi\big(L, X, Y, C, E\big) \ll_{arth}(30) \gg_{arth}(30) \\
  \end{cases}
  \label{eq:bitstring_get_2}
\end{equation}

As operações definidas em (\ref{eq:bitstring_get_2}) capturam informações armazenadas nos agentes, como especificado em (\ref{especificacaoAgente}).

Assim sendo, para o modelo \textit{bitstring} especificado neste trabalho, considere um agente $\chi(t)$ especificado como em (\ref{eq:ex_get_agente}), em que o símbolo $|$ designa o separador dos campos do agente.

\begin{equation}
  \chi(t) = 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \\
  \label{eq:ex_get_agente}
\end{equation}

A aplicação do operador de captura do campo de identificador do lote em que o agente $\chi(t)$ se encontra, como definido em (\ref{eq:bitstring_get_2}), é exemplificada como ilustrado em (\ref{eq:ex_get_l}).

\begin{equation}
  \begin{split}
  L(t) = & \chi(t) \ll_{arth}(0) \gg_{arth}(26) \\
       = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0  \ll_{arth}(0) \gg_{arth}(26) \\
       = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \gg_{arth}(26) \\
       = & 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 1 1 0 1 | 0 0 \\
       = & 1 1 0 1 0 0
  \label{eq:ex_get_l}
  \end{split}
\end{equation}

A aplicação do operador de captura do campo da coordenada $x$ do lote em que o agente $\chi(t)$ se encontra, como definido em (\ref{eq:bitstring_get_2}), é exemplificada como ilustrado em (\ref{eq:ex_get_x}).

\begin{equation}
  \begin{split}
  X(t) = & \chi(t) \ll_{arth}(6) \gg_{arth}(23) \\
       = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0  \ll_{arth}(6) \gg_{arth}(23) \\
       = & 0 0 1 0 1 0 | 1 0 0 0 1 1 0 0 1 | 0 1 1 0 0 1 1 1 0 | 1 0 0 0 0 0 | 0 0 \gg_{arth}(23) \\
       = & 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 1 0 1 0 1 | 0 0 \\
       = & 1 0 1 0 1 0 0
  \label{eq:ex_get_x}
  \end{split}
\end{equation}

A aplicação do operador de captura do campo da coordenada $y$ do lote em que o agente $\chi(t)$ se encontra, como definido em (\ref{eq:bitstring_get_2}), é exemplificada como ilustrado em (\ref{eq:ex_get_y}).

\begin{equation}
  \begin{split}
  Y(t) = & \chi(t) \ll_{arth}(15) \gg_{arth}(23) \\
       = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0  \ll_{arth}(15) \gg_{arth}(23) \\
       = & 0 1 1 0 0 1 | 0 1 1 0 0 1 1 1 0 | 1 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 | 0 0 \gg_{arth}(23) \\
       = & 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 1 1 0 0 1 0 | 1 1 \\
       = & 1 1 0 0 1 0 1 1
  \label{eq:ex_get_y}
  \end{split}
\end{equation}

A aplicação do operador de captura do campo do contador de transição de estados do agente $\chi(t)$, como definido em (\ref{eq:bitstring_get_2}), é exemplificada como ilustrado em (\ref{eq:ex_get_c}).

\begin{equation}
  \begin{split}
  C(t) = & \chi(t) \ll_{arth}(24) \gg_{arth}(26) \\
       = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0  \ll_{arth}(24) \gg_{arth}(26) \\
       = & 0 0 1 1 1 0 | 1 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 | 0 0 \gg_{arth}(26) \\
       = & 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 0 0 1 1 | 1 0 \\
       =  & 1 1 1 0
  \label{eq:ex_get_c}
  \end{split}
\end{equation}

A aplicação do operador de captura do campo do estado do agente $\chi(t)$, como definido em (\ref{eq:bitstring_get_2}), é exemplificada como ilustrado em (\ref{eq:ex_get_e}).

\begin{equation}
  \begin{split}
  E(t) = & \chi(t) \ll_{arth}(30) \gg_{arth}(30) \\
       = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0  \ll_{arth}(30) \gg_{arth}(30) \\
       = & 1 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 | 0 0 \gg_{arth}(30) \\
       = & 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 | 1 0 \\
       =  & 1 0
  \label{eq:ex_get_e}
  \end{split}
\end{equation}

Também são necessárias outras operações para manipular os atributos dos agentes, além daquelas definidas em (\ref{eq:bitstring_get_2}). Como a linguagem de programação C não conta com operador próprio que permita a execução de operações de deslocamentos circulares, faz-se necessário a sua definição com base nos operadores existentes na linguagem, como os deslocamentos aritméticos e operações lógicas. Em (\ref{eq:bitstring_circ}) $\ll_{circ}$ e $\gg_{circ}$ designam, respectivamente, deslocamentos circulares à esquerda e à direita na palavra, na quantidade de \textit{bits} indicado, definidos como uma composição dos operadores de deslocamento aritmético e a operação lógica ou.
\begin{equation}
  \begin{cases}
    \ll_{circ} = \big(M \ll_{arth}(shift)\big) \, \vee \, \big(M \gg_{arth}(N\_BITS - shift)\big) \\
    \gg_{circ} = \big(M \gg_{arth}(shift)\big) \, \vee \, \big(M \ll_{arth}(N\_BITS - shift)\big) \\
  \end{cases}
  \label{eq:bitstring_circ}
\end{equation}

Em (\ref{eq:bitstring_circ}), $M$ denota a palavra computacional em que está sendo aplicada a operação de deslocamento circular, $N\_BITS$ denota a quantidade de bits totais, \textit{shift} denota a quantidade de \textit{bits} para os deslocamentos e $\vee$ denota a operação lógica OR, "ou inclusivo", que é realizada \textit{bit} a \textit{bit} à palavra. Assim, a especificação às quantidades adotadas na modelagem, (\ref{eq:bitstring_circ}) é reescrita como em (\ref{eq:bitstring_circ_2}).
\begin{equation}
  \begin{cases}
    \ll_{circ} = \big(M \ll_{arth}(shift)\big) \, \vee \, \big(M \gg_{arth}(32 - shift)\big) \\
    \gg_{circ} = \big(M \gg_{arth}(shift)\big) \, \vee \, \big(M \ll_{arth}(32 - shift)\big) \\
  \end{cases}
  \label{eq:bitstring_circ_2}
\end{equation}

Em (\ref{eq:ex_circ_left}) é ilustrado um exemplo da aplicação do operador $\ll_{circ}$ definido em (\ref{eq:bitstring_circ_2}) em uma palavra computacional $M = 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 $ de 32 \textit{bits}, com $shift = 8$.

\begin{equation}
  \footnotesize
  \begin{split}
  \ll_{circ} = & \big(M \ll_{arth}(shift)\big) \, \vee \, \big(M \gg_{arth}(32 - shift)\big) \\
	     = & 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 \ll_{arth}(8) \, \vee \, 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 \gg_{arth}(32 - 8) \\
	     = & 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 \ll_{arth}(8) \, \vee \, 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 \gg_{arth}(24) \\
	     = & 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 | 0 0 0 0 0 0 0 0 \, \vee \, 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 1 1 0 1 0 0 0 0 \\
	     = & 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 | 1 1 0 1 0 0 0 0 \\
  \label{eq:ex_circ_left}
  \end{split}
\end{equation}

Em (\ref{eq:ex_circ_right}) é ilustrado um exemplo da aplicação do operador $\gg_{circ}$ definido em (\ref{eq:bitstring_circ_2}) em uma palavra computacional $M = 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 $ de 32 \textit{bits}, com $shift = 8$.

\begin{equation}
  \footnotesize
  \begin{split}
  \gg_{circ} = & \big(M \gg_{arth}(shift)\big) \, \vee \, \big(M \ll_{arth}(32 - shift)\big) \\
	     = & 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 \gg_{arth}(8) \, \vee \, 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 \ll_{arth}(32 - 8) \\
	     = & 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 \gg_{arth}(8) \, \vee \, 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 1 0 \ll_{arth}(24) \\  
	     = & 0 0 0 0 0 0 0 0 | 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 \, \vee \, 0 0 1 1 1 0 1 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0\\
	     = & 0 0 1 1 1 0 1 0 | 1 1 0 1 0 0 0 0 | 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 1 1 \\
  \label{eq:ex_circ_right}
  \end{split}
\end{equation}

Subsequentemente são utilizadas as operações definidas em (\ref{eq:bitstring_circ_2}), para implementar o operador espaço-temporal $\lambda\big(\chi(t)\big)$ que movimenta o agente da posição $(i,j)$ para uma posição $\big(\xi, \eta\big)$ no ciclo de tempo atual $t$, para o ciclo de tempo $t+1$. As operações definidas em (\ref{eq:bitstring_set}) resultam na atualização dos atributos de identificação do lote, das coordenadas $x$ e $y$ da posição, do controle e do estado do agente.
\begin{equation}
  \scriptsize
  \begin{cases}
    \chi\big(L(t + 1), X(t), Y(t), C(t), E(t)\big) = \chi\big(L(t), X(t), Y(t), C(t), E(t)\big) \gg_{circ}(Al) \gg_{arth}(\#l) \ll_{arth} (\#l) \, \vee \, L(t + 1) \ll_{circ}(Al) \\
    \chi\big(L(t), X(t + 1), Y(t), C(t), E(t)\big) = \chi\big(L(t), X(t), Y(t), C(t), E(t)\big) \gg_{circ}(Ax) \gg_{arth}(\#x) \ll_{arth} (\#x) \, \vee \, X(t + 1) \ll_{circ}(Ax) \\
    \chi\big(L(t), X(t), Y(t + 1), C(t), E(t)\big) = \chi\big(L(t), X(t), Y(t), C(t), E(t)\big) \gg_{circ}(Ay) \gg_{arth}(\#y) \ll_{arth} (\#y) \, \vee \, Y(t + 1) \ll_{circ}(Ay) \\
    \chi\big(L(t), X(t), Y(t), C(t + 1), E(t)\big) = \chi\big(L(t), X(t), Y(t), C(t), E(t)\big) \gg_{circ}(Ac) \gg_{arth}(\#c) \ll_{arth} (\#c) \, \vee \, C(t + 1) \ll_{circ}(Ac) \\
    \chi\big(L(t), X(t), Y(t), C(t), E(t + 1)\big) = \chi\big(L(t), X(t), Y(t), C(t), E(t)\big) \gg_{circ}(Ae) \gg_{arth}(\#e) \ll_{arth} (\#e) \, \vee \, E(t + 1) \ll_{circ}(Ae) \\
  \end{cases}
  \label{eq:bitstring_set}
\end{equation}

Em (\ref{eq:bitstring_set}), $Al$, $Ax$, $Ay$, $Ac$ e $Ae$ designam, respectivamente, as quantidades de \textit{bits} anteriores à cada campo. A quantidade de \textit{bits} anteriores à cada campo é a quantidade de \textit{bits} existentes que são menos significativos àqueles do campo em questão. Os termos $\#l$, $\#x$, $\#y$, $\#c$ e $\#e$ designam, respectivamente, as quantidades de \textit{bits} de cada campo. Como $Al = 26$, $Ax = 17$, $Ay = 8$, $Ac = 2$, $Ae = 0$, $\#l = 6$, $\#x = 9$, $\#y = 9$, $\#c = 6$ e $\#e = 2$, a especificação às quantidades adotadas na modelagem, (\ref{eq:bitstring_set}) é reescrita como em (\ref{eq:bitstring_set_2}).
\begin{equation}
  \scriptsize
  \begin{cases}
    \chi\big(L(t + 1), X(t), Y(t), C(t), E(t)\big) = \chi\big(L(t), X(t), Y(t), C(t), E(t)\big) \gg_{circ}(26) \gg_{arth}(6) \ll_{arth}(6) \, \vee \, L(t + 1) \ll_{circ}(26) \\
    \chi\big(L(t), X(t + 1), Y(t), C(t), E(t)\big) = \chi\big(L(t), X(t), Y(t), C(t), E(t)\big) \gg_{circ}(17) \gg_{arth}(9) \ll_{arth}(9) \, \vee \, X(t + 1) \ll_{circ}(17) \\
    \chi\big(L(t), X(t), Y(t + 1), C(t), E(t)\big) = \chi\big(L(t), X(t), Y(t), C(t), E(t)\big) \gg_{circ}(8) \gg_{arth}(9) \ll_{arth}(9) \, \vee \, Y(t + 1) \ll_{circ}(8) \\
    \chi\big(L(t), X(t), Y(t), C(t + 1), E(t)\big) = \chi\big(L(t), X(t), Y(t), C(t), E(t)\big) \gg_{circ}(2) \gg_{arth}(6) \ll_{arth}(6) \, \vee \, C(t + 1) \ll_{circ}(2) \\
    \chi\big(L(t), X(t), Y(t), C(t), E(t + 1)\big) = \chi\big(L(t), X(t), Y(t), C(t), E(t)\big) \gg_{circ}(0) \gg_{arth}(2) \ll_{arth}(2) \, \vee \, E(t + 1) \ll_{circ}(0) \\
  \end{cases}
  \label{eq:bitstring_set_2}
\end{equation}

Considere novamente o agente $\chi(t)$ especificado em (\ref{eq:ex_get_agente}), em que o símbolo $|$ designa o separador dos campos do agente. A aplicação do operador definido em (\ref{eq:bitstring_set_2}) para a configuração do campo do identificador do lote do agente $\chi(t)$ de $L(t)$ para $L(t + 1)$, é exemplificada como ilustrado em (\ref{eq:ex_set_l}), considerando $L(t + 1) = 0 0 1 1 1 1$.

\begin{equation}
  \small
  \begin{split}
  \chi(t + 1) = & \chi(t) \gg_{circ}(26) \gg_{arth}(6) \ll_{arth}(6) \, \vee \, L(t + 1) \ll_{circ}(26) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \gg_{circ}(26) \gg_{arth}(6) \ll_{arth}(6) \, \vee \, 0 0 1 1 1 1 \ll_{circ}(26) \\
  = & 0 0 1 0 1 0 | 1 0 0 0 1 1 0 0 1 | 0 1 1 0 0 1 1 1 0 | 1 0 1 1 0 1 | 0 0 \gg_{arth}(6) \ll_{arth}(6) \, \vee \, 0 0 1 1 1 1 \ll_{circ}(26) \\
  = & 0 0 0 0 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \ll_{arth}(6) \, \vee \, 0 0 1 1 1 1 \ll_{circ}(26) \\
  = & 0 0 1 0 1 0 | 1 0 0 0 1 1 0 0 1 | 0 1 1 0 0 1 1 1 0 | 1 0 0 0 0 0 | 0 0 \, \vee \, 0 0 1 1 1 1 \ll_{circ}(26) \\
  = & 0 0 1 0 1 0 | 1 0 0 0 1 1 0 0 1 | 0 1 1 0 0 1 1 1 0 | 1 0 0 0 1 1 | 1 1 \ll_{circ}(26) \\
  = & 0 0 1 1 1 1 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \\
  \label{eq:ex_set_l}
  \end{split}
\end{equation}

A aplicação do operador definido em (\ref{eq:bitstring_set_2}) para a configuração do campo da coordenada $x$ do lote do agente $\chi(t)$ de $X(t)$ para $X(t + 1)$, é exemplificada como ilustrado em (\ref{eq:ex_set_x}), considerando $X(t + 1) = 1 1 0 0 0 0 1 1 1$.

\begin{equation}
  \small
  \begin{split}
  \chi(t + 1) = & \chi(t) \gg_{circ}(17) \gg_{arth}(9) \ll_{arth}(9) \, \vee \, X(t + 1) \ll_{circ}(17) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \gg_{circ}(17) \gg_{arth}(9) \ll_{arth}(9) \, \vee \, 1 1 0 0 0 0 1 1 1 \ll_{circ}(17) \\
  = & 0 1 1 0 0 1 | 0 1 1 0 0 1 1 1 0 | 1 0 1 1 0 1 0 0 0 | 0 1 0 1 0 1 | 0 0 \gg_{arth}(9) \ll_{arth}(9) \, \vee \, 1 1 0 0 0 0 1 1 1 \ll_{circ}(17) \\
  = & 0 0 0 0 0 0 | 0 0 0 0 1 1 0 0 1 | 0 1 1 0 0 1 1 1 0 | 1 0 1 1 0 1 | 0 0 \ll_{arth}(9) \, \vee \, 1 1 0 0 0 0 1 1 1 \ll_{circ}(17) \\
  = & 0 1 1 0 0 1 | 0 1 1 0 0 1 1 1 0 | 1 0 1 1 0 1 0 0 0 | 0 0 0 0 0 0 | 0 0 \, \vee \, 1 1 0 0 0 0 1 1 1 \ll_{circ}(17) \\
  = & 0 1 1 0 0 1 | 0 1 1 0 0 1 1 1 0 | 1 0 1 1 0 1 0 0 1 | 1 0 0 0 0 1 | 1 1 \ll_{circ}(17) \\
  = & 1 1 0 1 0 0 | 1 1 0 0 0 0 1 1 1 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \\
  \label{eq:ex_set_x}
  \end{split}
\end{equation}

A aplicação do operador definido em \ref{eq:bitstring_set_2} para a configuração do campo da coordenada $y$ do lote do agente $\chi(t)$ de $Y(t)$ para $Y(t + 1)$, é exemplificada como ilustrado em \ref{eq:ex_set_y}, considerando $Y(t + 1) = 1 1 1 1 0 1 0 0 0$.

\begin{equation}
  \small
  \begin{split}
  \chi(t + 1) = & \chi(t) \gg_{circ}(8) \gg_{arth}(9) \ll_{arth}(9) \, \vee \, Y(t + 1) \ll_{circ}(8) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \gg_{circ}(8) \gg_{arth}(9) \ll_{arth}(9) \, \vee \, 1 1 1 1 0 1 0 0 0 \ll_{circ}(8) \\
  = & 0 0 1 1 1 0 | 1 0 1 1 0 1 0 0 0 | 0 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 | 1 1 \gg_{arth}(9) \ll_{arth}(9) \, \vee \, 1 1 1 1 0 1 0 0 0 \ll_{circ}(8) \\
  = & 0 0 0 0 0 0 | 0 0 0 0 0 1 1 1 0 | 1 0 1 1 0 1 0 0 0 | 0 1 0 1 0 1 | 0 0 \ll_{arth}(9) \, \vee \, 1 1 1 1 0 1 0 0 0 \ll_{circ}(8) \\
  = & 0 0 1 1 1 0 | 1 0 1 1 0 1 0 0 0 | 0 1 0 1 0 1 0 0 0 | 0 0 0 0 0 0 | 0 0 \, \vee \, 1 1 1 1 0 1 0 0 0 \ll_{circ}(8) \\
  = & 0 0 1 1 1 0 | 1 0 1 1 0 1 0 0 0 | 0 1 0 1 0 1 0 0 1 | 1 1 1 0 1 0 | 0 0 \ll_{circ}(8) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 1 1 1 1 0 1 0 0 0 | 0 0 1 1 1 0 | 1 0 \\
  \label{eq:ex_set_y}
  \end{split}
\end{equation}

A aplicação do operador definido em \ref{eq:bitstring_set_2} para a configuração do campo do contador de transição de estados do agente $\chi(t)$ de $C(t)$ para $C(t + 1)$, é exemplificada como ilustrado em \ref{eq:ex_set_c}, considerando $C(t + 1) = 1 0 1 0 1 1$.

\begin{equation}
  \small
  \begin{split}
  \chi(t + 1) = & \chi(t) \gg_{circ}(2) \gg_{arth}(6) \ll_{arth}(6) \, \vee \, C(t + 1) \ll_{circ}(2) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \gg_{circ}(2) \gg_{arth}(6) \ll_{arth}(6) \, \vee \, 1 0 1 0 1 1 \ll_{circ}(2) \\
  = & 1 0 1 1 0 1 | 0 0 0 0 1 0 1 0 1 | 0 0 0 1 1 0 0 1 0 | 1 1 0 0 1 1 | 1 0 \gg_{arth}(6) \ll_{arth}(6) \, \vee \, 1 0 1 0 1 1 \ll_{circ}(2) \\
  = & 0 0 0 0 0 0 | 1 0 1 1 0 1 0 0 0 | 0 1 0 1 0 1 0 0 0 | 1 1 0 0 1 0 | 1 1 \ll_{arth}(6) \, \vee \, 1 0 1 0 1 1 \ll_{circ}(2) \\
  = & 1 0 1 1 0 1 | 0 0 0 0 1 0 1 0 1 | 0 0 0 1 1 0 0 1 0 | 1 1 0 0 0 0 | 0 0 \, \vee \, 1 0 1 0 1 1 \ll_{circ}(2) \\
  = & 1 0 1 1 0 1 | 0 0 0 0 1 0 1 0 1 | 0 0 0 1 1 0 0 1 0 | 1 1 1 0 1 0 | 1 1 \ll_{circ}(2) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 1 0 1 0 1 1 | 1 0 \\
  \label{eq:ex_set_c}
  \end{split}
\end{equation}

A aplicação do operador definido em \ref{eq:bitstring_set_2} para a configuração do campo do estado do agente $\chi(t)$ de $E(t)$ para $E(t + 1)$, é exemplificada como ilustrado em \ref{eq:ex_set_e}, considerando $E(t + 1) = 0 1$.

\begin{equation}
  \small
  \begin{split}
  \chi(t + 1) = & \chi(t) \gg_{circ}(0) \gg_{arth}(2) \ll_{arth}(2) \, \vee \, E(t + 1) \ll_{circ}(0) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \gg_{circ}(0) \gg_{arth}(2) \ll_{arth}(2) \, \vee \, 0 1 \ll_{circ}(0) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 1 0 \gg_{arth}(2) \ll_{arth}(2) \, \vee \, 0 1 \ll_{circ}(0) \\
  = & 0 0 1 1 0 1 | 0 0 0 0 1 0 1 0 1 | 0 0 0 1 1 0 0 1 0 | 1 1 0 0 1 1 | 1 0 \ll_{arth}(2) \, \vee \, 0 1 \ll_{circ}(0) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 0 0 \, \vee \, 0 1 \ll_{circ}(0) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 0 1 \ll_{circ}(0) \\
  = & 1 1 0 1 0 0 | 0 0 1 0 1 0 1 0 0 | 0 1 1 0 0 1 0 1 1 | 0 0 1 1 1 0 | 0 1 \\
  \label{eq:ex_set_e}
  \end{split}
\end{equation}

Na Tabela \ref{tab:variaveis} são apresentados sistematicamente os valores relativos às quantidades de \textit{bits} dos tamanhos, complementos, posteriores e anteriores de cada atributo do agente $\chi$.

\begin{table}[h!]
\centering
\begin{tabular}{c|c|c|c|c}
  Atributo & Tamanho & Complementar & Posteriores & Anteriores \\ \hline
  Identificador do Lote $L$ 	& 6 & 26 & 0 & 26 \\
  Coordenada $X$ 		& 9 & 23 & 6 & 17 \\
  Coordenada $Y$ 		& 9 & 23 & 15 & 8 \\
  Contador de Controle $C$ 	& 6 & 26 & 24 & 2 \\
  Estado $E$ 			& 2 & 30 & 30 & 0 \\
\end{tabular}
\caption{Tabela das variáveis relacionadas aos campos dos agentes}
\label{tab:variaveis}
\end{table}

Para completar a modelagem é suficiente detalhar e relacionar os identificadores dos lotes e dimensões dos lotes, a faixa de variação do controle, e os possíveis tipos de estados do agente na base $10$, com tais características na base $2$, para determinar sem ambigüidade os elementos de \ref{especificacaoAgente}. Os identificadores dos lotes têm variação de $\big(0\big)_{10} = \big(000\ 000\big)_{2}$ até $\big(63\big)_{10} = \big(111\ 111\big)_{2}$, totalizando $64$ possíveis valores. Os lotes têm dimensão máxima de $512_{10} = 2^{9}$ linhas por $512_{10} = 2^{9}$ colunas, sendo possível variarem numa representação matricial da posição $\big(0; 0\big)_{10} = \big(000\ 000\ 000; 000\ 000\ 000\big)_{2}$ até a posição $\big(511; 511\big)_{10} = \big(111\ 111\ 111; 111\ 111\ 111\big)_{2}$, totalizando os $512$ possíveis valores. Semelhantemente, faz-se uma representação matricial ao controle para que sua variação ocorra de $\big(0\big)_{10} = \big(000\ 000\big)_{2}$ até $\big(63\big)_{10} = \big(111\ 111\big)_{2}$, totalizando os $64$ possíveis valores. Os estados do agente são setados como $\big(0, 0\big)_{2}$ para o suscetível, $S$, $\big(0, 1\big)_{2}$ para o exposto, $E$, $\big(1, 0\big)_{2}$ para o infectante, $I$, e $\big(1, 1\big)_{2}$ para o recuperado, $R$.

%\section{Estruturas de Dados, Linguagens e Estratégias de Implementação}

%\section{CUDA e OpenMP}

%\section{SIMULA}